What is spring?
Dependency Injection framework to make java application loosely coupled.
makes it easy to develop javaEE application

What is Dependency Injection?
It is Design pattern. 
It makes our application loosely coupled.

Inversion Of Control?
It creates the object in runtime and provide the object using Dependency Injection.

Spring Modules?
- Spring Core - Core, Beans, Context, spEL -> provides DI, IOC -> Dependency to add spring-core, spring-context
- AOP
- Data Access/ Integration - JDBC, ORM, JMS, OXM -> we can use hibernate or jpa using ORM
- Spring Web - Web, Servlet

Spring IOC Container?
Responsible for object creation, hold object in memory, inject one object inside another object.
Responsible for lifecycle of object from creation to destruction.
Using Beans and xml Configuration file.

ApplicationContext extends BeanFactory - Interface that represents IOC Container
ClasspathXMLApplicationContext - search for the xml Configuration in the java classpath -- MOST USED
AnnotationConfigApplicationContext - search for bean where we have used annotation

Beans - Java Class that we provide to xml file to create object of class and follow lifecycle of object creation to destruction

Dependency Injection can be done in two ways--
Setter Injection
Constructor Injection

Data Types that supports Dependency Injection
- Primitive Data Types
- Collection Types - List, Set, Map and Properties
- Reference Data Types - Other class object

How to inject Dependency Injection?
Using property file xml 
<beans><bean class="com.example.Student" name="st1"> <property name="studentId"><value>Faraz</value></property></bean></beans>

Lifecycle of Spring Bean-
public void init() - initialisation code, config, connecting db
public void destroy() - cleanup code

Create object, instatiate object, call init(), read and use the bean, call destroy()

Autowiring - 
Spring container inject the dependency automatically.
Using @Autowired annotation

@Qualifier Annotation - 
It is used to specify the name of the bean that we want to use.

@Component Annotation - 
Spring will create the object of that particular class automatically. We can provide name of the bean in @Component("Name")

@Value Annotation - 
Populate the property value on spring startup.

Spring Beaan Scope - 
Singleton - Default - Only one object has been created by spring and we use that object anytime we want to use the object
Prototype - Everytime new object has been created whenever we call
request 
session
globalsession

@Scaope annotation used with only @Component annotation -> Define scope of bean @Scope("prototype")

@Configuration -> To handle the configuration using java
@ComponentScan -> provide basePackages so that spring will scan that package and create the bean of any class that have @Component / @Bean annotation.

@Bean -> The object is provided to IOC container to use in future.

If using @Bean annotation then we dont have to use @ComponentScan

======================================================================

Spring JDBC
-----------
We can connect with database and execute query using spring jdbc.

It provides JdbcTemplate to perform all the important operation using methods provided by the class.



Spring ORM (Object Relational Mapping)
--------------------------------------
HibernateTemplate class - save(), update(), insert(), get(), loadAll() -> SessionFactory -> LocalSessionFactory -> DataSource




@Entity 
@Table -> Treat the class as database Table

=====================================================================

Why spring security is needed at first place in your application?
-------------------------------------------------------------------
Spring Security is essential in an application for several reasons:

### 1. **Authentication**:
   - **User Verification**: Spring Security provides robust mechanisms for authenticating users. It supports various authentication methods such as form-based login, HTTP Basic authentication, and OAuth2, ensuring that only legitimate users can access the application.

### 2. **Authorization**:
   - **Access Control**: It allows fine-grained control over which users or roles can access certain parts of the application. This helps in enforcing rules like "only admins can delete records" or "only authenticated users can view this page."

### 3. **Protection Against Common Vulnerabilities**:
   - **CSRF Protection**: Cross-Site Request Forgery (CSRF) is a common web application vulnerability. Spring Security automatically includes CSRF protection mechanisms to prevent unauthorized commands being transmitted from a user that the web application trusts.
   - **XSS Protection**: It helps prevent Cross-Site Scripting (XSS) attacks by sanitizing inputs and outputs, ensuring that malicious scripts cannot be executed in the user's browser.
   - **Clickjacking Protection**: It provides defense against clickjacking attacks by allowing the application to control how its pages are displayed in iframes.

### 4. **Session Management**:
   - **Session Fixation Protection**: Spring Security helps mitigate session fixation attacks, where attackers attempt to take over a user's session.
   - **Concurrent Session Control**: It can limit the number of sessions a user can have open simultaneously, which is useful for sensitive applications.

### 5. **Customizable Security**:
   - **Extensible Framework**: Spring Security is highly customizable, allowing developers to define custom security rules, authentication providers, and even integrate with other security frameworks or services.

### 6. **Ease of Integration**:
   - **Spring Ecosystem**: Since Spring Security is part of the Spring ecosystem, it integrates seamlessly with other Spring modules, making it easier to build secure, enterprise-grade applications.

### 7. **Compliance and Auditing**:
   - **Audit Trails**: It helps in keeping track of security-related events such as login attempts, role changes, and unauthorized access attempts, which is crucial for compliance and auditing purposes.

Overall, Spring Security provides a comprehensive and customizable security framework that helps protect applications against a wide range of security threats, ensuring that sensitive data and operations are secure.

How Spring Security is used to secure your application at a high level?
-----------------------------------------------------------------------
Spring Security is used to secure applications at a high level through several key mechanisms:

### 1. **Authentication**:
   - **User Authentication**: Spring Security handles the process of authenticating users when they attempt to log in. This is typically done by comparing the user's credentials (such as username and password) against a stored user database (like in-memory, database-backed, LDAP, etc.).
   - **Integration with OAuth2/OpenID Connect**: For applications requiring integration with third-party identity providers (e.g., Google, Facebook), Spring Security can manage OAuth2 and OpenID Connect authentication.

### 2. **Authorization**:
   - **Role-Based Access Control (RBAC)**: After authentication, Spring Security determines what resources or actions the authenticated user is allowed to access based on their roles or authorities. This is done using annotations like `@PreAuthorize`, `@Secured`, or in the security configuration through URL-based restrictions.
   - **Method-Level Security**: Spring Security allows you to apply security at the method level using annotations, ensuring that sensitive business logic can only be accessed by users with the appropriate permissions.

### 3. **Security Configuration**:
   - **HTTP Security**: Spring Security provides a powerful DSL to configure security policies on HTTP requests. For example, you can specify which endpoints require authentication, configure form login, enable HTTPS, and define CORS policies.
   - **Security Filters**: The core of Spring Security is a chain of filters that intercept incoming requests. These filters handle everything from authentication to authorization, CSRF protection, session management, and more.

### 4. **Session Management**:
   - **Session Fixation Protection**: By default, Spring Security helps protect against session fixation attacks by creating a new session ID upon successful login.
   - **Concurrent Session Control**: You can configure Spring Security to control the number of sessions a user can have simultaneously, and decide how to handle session timeouts and expirations.

### 5. **CSRF Protection**:
   - **Cross-Site Request Forgery (CSRF)**: Spring Security automatically includes CSRF tokens in forms and verifies these tokens on submission to prevent unauthorized commands being sent by malicious users or scripts.

### 6. **Password Management**:
   - **Password Encoding**: Spring Security provides utilities for securely hashing and storing passwords using modern algorithms like bcrypt. It also supports password policies, such as requiring strong passwords.

### 7. **Security Context**:
   - **SecurityContextHolder**: Spring Security uses `SecurityContextHolder` to store authentication details (like user information) for the current user session. This context can be accessed throughout the application, enabling security checks and decisions to be made.

### 8. **Custom Authentication and Authorization**:
   - **Custom Authentication Providers**: If the standard authentication mechanisms don't fit your needs, Spring Security allows you to create custom authentication providers to validate users against any custom logic or external system.
   - **Custom Filters**: You can define custom security filters to implement specific security checks or modify the security flow.

### 9. **Audit and Logging**:
   - **Event Logging**: Spring Security can log security events such as authentication failures, successful logins, and access denials. This is useful for auditing and monitoring potential security breaches.

### 10. **Integration with Spring Boot**:
   - **Auto-Configuration**: In Spring Boot applications, Spring Security is auto-configured, meaning that with minimal setup, you get a secure application out of the box. The defaults are secure, but you can override them to meet your specific needs.

At a high level, Spring Security is embedded throughout the application lifecycle, from intercepting requests to enforcing security policies, authenticating users, authorizing actions, and protecting against common security threats. This integrated approach ensures that the application is secured comprehensively and consistently.

Types of Authentication?
------------------------
Authentication is the process of verifying the identity of a user or system. There are several types of authentication methods that can be implemented depending on the security requirements of an application. Here are some common types:

### 1. **Password-Based Authentication**
   - **Description**: This is the most common form of authentication where users provide a username and password to gain access. The password is typically stored in a hashed format in the database.
   - **Examples**: Logging into a website with a username and password.

### 2. **Multi-Factor Authentication (MFA)**
   - **Description**: MFA requires two or more verification factors to authenticate a user. It adds an extra layer of security beyond just a password.
   - **Factors**:
     - **Something you know**: A password or PIN.
     - **Something you have**: A security token, mobile phone, or smart card.
     - **Something you are**: Biometrics like fingerprints, facial recognition, or iris scans.
   - **Examples**: A banking app that requires a password and a one-time code sent to your mobile device.

### 3. **Token-Based Authentication**
   - **Description**: After the initial login, the server generates a token (like JWT - JSON Web Token) and sends it to the client. The client stores this token and sends it with subsequent requests. The server validates the token to authenticate the user.
   - **Examples**: APIs using JWT tokens for authentication, OAuth2 tokens.

### 4. **Certificate-Based Authentication**
   - **Description**: This method uses digital certificates to identify and authenticate a user or device. A certificate is issued by a trusted certificate authority (CA) and is used in scenarios requiring high security.
   - **Examples**: SSL/TLS client certificates used in VPN connections or secure websites.

### 5. **Biometric Authentication**
   - **Description**: This form of authentication uses unique biological characteristics of the user for verification. It's considered very secure because it’s difficult to replicate biological data.
   - **Examples**: Fingerprint scanning, facial recognition, voice recognition, or retina scanning.

### 6. **One-Time Password (OTP) Authentication**
   - **Description**: OT passwords are valid for only one login session or transaction. They are typically sent to the user’s mobile phone or email and must be entered within a short time frame.
   - **Examples**: SMS-based OTPs for online banking transactions, Google Authenticator codes.

### 7. **Single Sign-On (SSO)**
   - **Description**: SSO allows users to log in once and gain access to multiple related systems without having to log in again for each system. It typically uses protocols like SAML, OAuth, or OpenID Connect.
   - **Examples**: Logging into a corporate network and automatically gaining access to multiple enterprise applications.

### 8. **Social Authentication**
   - **Description**: Users can log into a third-party application using their credentials from a social networking service like Facebook, Google, or Twitter. This is usually implemented using OAuth2.
   - **Examples**: Logging into a website using your Google or Facebook account.

### 9. **Risk-Based Authentication (Adaptive Authentication)**
   - **Description**: This dynamic authentication method evaluates the risk associated with a login attempt based on factors like location, device, behavior patterns, and more. Based on the risk, it may require additional verification.
   - **Examples**: A bank requiring additional verification if a login is attempted from a new device or unusual location.

### 10. **Challenge-Response Authentication**
   - **Description**: In this method, the user is presented with a challenge (usually a question or an image) that they must respond to correctly to authenticate.
   - **Examples**: Security questions, CAPTCHA.

### 11. **Public Key Authentication**
   - **Description**: In public key authentication, a user’s identity is verified using a pair of cryptographic keys: a public key and a private key. The user signs a message with their private key, and the server verifies it using the user's public key.
   - **Examples**: SSH key-based authentication in server access.

### 12. **Kerberos Authentication**
   - **Description**: Kerberos is a network authentication protocol designed to provide strong authentication for client-server applications. It uses secret-key cryptography and a trusted third party (a Key Distribution Center).
   - **Examples**: Authentication in Windows domains.

Each of these methods can be used independently or in combination to enhance the security of an application, depending on the sensitivity of the data and the security requirements.

What are the core concepts of spring security?
----------------------------------------------
Spring Security is a powerful and flexible security framework that provides authentication, authorization, and other security-related features for Java applications. The core concepts of Spring Security are:

### 1. **Security Context**
   - **SecurityContextHolder**: This is the central place where Spring Security stores details about the current security context of the application, including authentication details. It is accessible throughout the application, allowing you to retrieve information about the current user.
   - **Authentication**: The `Authentication` object stored in the `SecurityContext` represents the currently authenticated user. It contains details like the username, password, granted authorities (roles), and other credentials.

### 2. **Authentication**
   - **AuthenticationManager**: This is the core interface responsible for processing authentication requests. It delegates to one or more `AuthenticationProvider` instances to validate user credentials.
   - **AuthenticationProvider**: An `AuthenticationProvider` is responsible for authenticating a user with a specific type of credentials (e.g., username/password, OAuth token). Multiple providers can be chained to support different authentication mechanisms.

### 3. **Authorization**
   - **GrantedAuthority**: Represents an authority or role that is granted to the user. These authorities determine what actions the user is allowed to perform within the application.
   - **AccessDecisionManager**: This is responsible for making final access control decisions. It works with `AccessDecisionVoter` objects to evaluate if a user has the necessary permissions to access a specific resource or perform an action.

### 4. **Security Filters**
   - **Filter Chain**: Spring Security uses a series of filters to process security logic. Each filter performs a specific security function, such as authentication, authorization, session management, or CSRF protection. The filters are organized into a chain that intercepts HTTP requests before they reach the application’s controllers.
   - **UsernamePasswordAuthenticationFilter**: This filter is responsible for processing login requests containing username and password.
   - **BasicAuthenticationFilter**: This filter handles HTTP Basic authentication, where the user's credentials are sent with every request in an HTTP header.

### 5. **Security Configuration**
   - **WebSecurityConfigurerAdapter**: This is a base class used to configure security settings in a Spring application. It provides methods to customize authentication, authorization, HTTP security, and more.
   - **HttpSecurity**: A fluent API provided by Spring Security to configure security settings for HTTP requests, such as defining URL patterns that require authentication, configuring form login, CSRF protection, and more.
   - **Global Method Security**: This allows you to apply security constraints at the method level using annotations like `@Secured`, `@PreAuthorize`, and `@RolesAllowed`.

### 6. **UserDetails and UserDetailsService**
   - **UserDetails**: This interface represents the user’s core information, including username, password, and authorities. It is a central part of the authentication process.
   - **UserDetailsService**: This service is responsible for retrieving the `UserDetails` object based on the provided username during the authentication process.

### 7. **Password Management**
   - **PasswordEncoder**: This interface defines how passwords are encoded and verified in Spring Security. Implementations like `BCryptPasswordEncoder` provide secure password hashing.
   - **Password Storage**: Spring Security encourages storing passwords in a hashed format, not in plain text, to enhance security.

### 8. **Session Management**
   - **SessionManagementFilter**: This filter is responsible for managing user sessions, including protecting against session fixation attacks and controlling the number of concurrent sessions a user can have.
   - **Session Timeout and Invalid Sessions**: You can configure session timeout policies and how to handle invalid sessions (e.g., redirecting to the login page).

### 9. **CSRF Protection**
   - **CsrfFilter**: This filter adds CSRF (Cross-Site Request Forgery) protection to the application by generating and validating CSRF tokens in forms and requests.
   - **CSRF Token**: A unique token that is generated for each session and must be included in forms and requests to validate that the request comes from an authenticated user.

### 10. **Security Expressions**
   - **@PreAuthorize, @PostAuthorize**: These annotations allow you to apply security constraints using SpEL (Spring Expression Language) expressions. For example, `@PreAuthorize("hasRole('ADMIN')")` restricts access to methods based on the user's role.
   - **Web Expression Language**: Used in `HttpSecurity` configurations to define access control rules, such as `hasRole('USER')` or `permitAll()`.

### 11. **Remember-Me Authentication**
   - **Remember-Me Cookie**: This feature allows users to stay logged in between sessions by storing a special token in a cookie. When the user returns, the token is used to authenticate them automatically.
   - **RememberMeAuthenticationFilter**: The filter responsible for checking the remember-me token in requests and automatically authenticating the user if the token is valid.

### 12. **Social Authentication**
   - **OAuth2 and OpenID Connect**: Spring Security provides support for integrating with external identity providers (e.g., Google, Facebook) using OAuth2 and OpenID Connect, allowing users to log in with their social media accounts.

### 13. **Custom Security**
   - **Custom Filters**: You can create custom filters to add specific security logic to your application.
   - **Custom Authentication and Authorization**: You can implement custom `AuthenticationProvider` and `AccessDecisionVoter` classes to meet unique security requirements.

These core concepts form the foundation of Spring Security, allowing developers to build secure applications by addressing authentication, authorization, session management, and protection against common security threats.

Authentication -> uthorization -> Principle -> Granted Authority -> Roles
Role -> Group of authorities
authorities -> Group of permissions

How is spring security intercepting your requests?
--------------------------------------------------
Spring Security intercepts requests in a Spring application by using a chain of security filters that process incoming HTTP requests before they reach the application’s controllers or other processing logic. Here's how this interception works:

### 1. **DelegatingFilterProxy**
   - **Integration with Servlet Container**: The Spring Security filter chain is registered with the servlet container (like Tomcat) using a `DelegatingFilterProxy`. This proxy acts as a bridge between the servlet container and the Spring-managed security filters.
   - **Filter Invocation**: When a request comes in, the servlet container passes it to the `DelegatingFilterProxy`, which in turn delegates the request to the Spring Security filter chain.

### 2. **Security Filter Chain**
   - **FilterChainProxy**: The `FilterChainProxy` is the core component that manages the security filter chain. It delegates the request to the appropriate set of security filters based on the URL pattern matching.
   - **Order of Filters**: The security filters are ordered and executed in sequence. Each filter has a specific responsibility, such as authentication, authorization, session management, CSRF protection, etc.

### 3. **Key Filters in the Chain**
   - **Security Filters**: Some of the key filters in the Spring Security filter chain include:
     - **`UsernamePasswordAuthenticationFilter`**: Handles form-based login requests, authenticating users based on submitted credentials.
     - **`BasicAuthenticationFilter`**: Processes HTTP Basic authentication headers to authenticate users.
     - **`CsrfFilter`**: Adds and validates CSRF tokens to protect against CSRF attacks.
     - **`ExceptionTranslationFilter`**: Handles exceptions related to security, such as access denied or authentication failures, and translates them into appropriate HTTP responses.
     - **`FilterSecurityInterceptor`**: This is the last filter in the chain that performs authorization checks based on the authenticated user's roles and the requested URL.
     - **`SecurityContextPersistenceFilter`**: Manages the `SecurityContext`, which holds the authentication information for the request, storing it in the `SecurityContextHolder`.
     - **`AnonymousAuthenticationFilter`**: Provides a default authentication object for requests where no user is authenticated, allowing anonymous access to specified resources.

### 4. **Processing the Request**
   - **Filter Execution**: As the request passes through the security filter chain, each filter performs its function. For example, the authentication filter checks if the user is logged in, and the authorization filter checks if the user has the necessary permissions to access the requested resource.
   - **Decision Making**: If a filter decides that the request should not proceed (e.g., due to failed authentication or lack of permissions), it can block the request and send an appropriate response (like a redirect to a login page or a 403 Forbidden status).

### 5. **Final Destination**
   - **Controller Access**: If all security checks are passed, the request reaches the application's controllers or other processing logic. The controller can then handle the request as usual, with the knowledge that it has passed all security checks.

### 6. **Customizing the Filter Chain**
   - **Custom Filters**: You can add custom filters to the chain by configuring them in the security configuration. This allows you to introduce custom security logic or modify the behavior of existing filters.
   - **Ordering**: The order of filters in the chain is crucial, as it determines the flow of security processing. Spring Security provides options to customize this order to fit specific security needs.

### 7. **Security Configuration**
   - **HttpSecurity Configuration**: In a Spring Boot application, you typically configure the security filter chain in a class that extends `WebSecurityConfigurerAdapter` (or by using the newer `SecurityFilterChain` bean). This is where you define which filters to use, how URLs should be secured, and which authentication mechanisms to apply.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/public/**").permitAll() // Allow public access
            .anyRequest().authenticated()          // All other requests require authentication
            .and()
        .formLogin()                               // Enable form-based login
            .loginPage("/login")                   // Custom login page
            .permitAll()
            .and()
        .logout()
            .permitAll();
}
```

### 8. **Outcome**
   - **Authenticated Request**: If the request is authenticated and authorized, it is passed through to the application’s business logic.
   - **Blocked Request**: If the request fails any of the security checks, an appropriate error response is sent back, such as a redirect to the login page, or an error page indicating access is denied.

In summary, Spring Security intercepts and processes requests using a well-defined chain of filters that apply authentication, authorization, and other security checks, ensuring that only legitimate requests are allowed to proceed to the application's business logic.

Different Type of Cache Mechanisms Available in Spring Boot
===========================================================
Spring Boot offers several caching mechanisms to optimize the performance of applications by storing frequently accessed data in memory. Here’s an overview of the key caching mechanisms available in Spring Boot:

### 1. **In-Memory Caching**
   - **Simple Cache (ConcurrentMapCache)**
     - This is the default caching implementation in Spring Boot.
     - It uses a `ConcurrentHashMap` to store cache entries.
     - It is lightweight and easy to set up, but the cache is lost when the application restarts.
     - Suitable for small, simple applications or caching during runtime.

     **Example:**
     ```java
     @Cacheable("books")
     public Book findBookByIsbn(String isbn) {
         // fetch book details from database
     }
     ```

### 2. **Ehcache**
   - Ehcache is a popular, robust, and widely used caching library.
   - It supports both in-memory and disk-based storage, with optional eviction strategies like LRU (Least Recently Used).
   - Suitable for large-scale applications where distributed caching and persistent caching are needed.
   - Spring Boot integrates with Ehcache easily by including the necessary dependency.

     **Example (Ehcache Configuration):**
     ```xml
     <ehcache>
         <cache name="books"
                maxEntriesLocalHeap="1000"
                timeToLiveSeconds="600">
         </cache>
     </ehcache>
     ```

### 3. **Hazelcast**
   - Hazelcast is a distributed in-memory data grid that supports caching.
   - It provides high availability, scalability, and fast access to cached data across multiple nodes.
   - Hazelcast allows you to use distributed caching across a cluster of applications.

     **Example (Hazelcast Configuration in `application.yml`):**
     ```yaml
     spring:
       cache:
         hazelcast:
           config: classpath:hazelcast.xml
     ```

### 4. **Caffeine Cache**
   - Caffeine is an in-memory caching library known for high performance.
   - It offers features like automatic eviction, size-based cache, and time-based expiration (TTL).
   - It’s more efficient than `ConcurrentMapCache` and is ideal for performance-sensitive applications.

     **Example (Caffeine Configuration):**
     ```yaml
     spring:
       cache:
         caffeine:
           spec: maximumSize=500,expireAfterWrite=10m
     ```

### 5. **Redis Cache**
   - Redis is an open-source, in-memory key-value data store often used as a cache.
   - Spring Boot integrates with Redis for distributed caching that persists even if the application restarts.
   - It’s ideal for distributed systems where the cache needs to be shared across multiple instances of an application.

     **Example:**
     ```yaml
     spring:
       cache:
         type: redis
       redis:
         host: localhost
         port: 6379
     ```

### 6. **Guava Cache**
   - Guava Cache is a simple caching library from Google, similar to Caffeine but less feature-rich.
   - It supports basic caching with time-based expiration and size-based eviction policies.

     **Example (Guava Cache in Java):**
     ```java
     @Bean
     public CacheManager cacheManager() {
         GuavaCacheManager cacheManager = new GuavaCacheManager("books");
         cacheManager.setCacheBuilder(CacheBuilder.newBuilder().expireAfterWrite(10, TimeUnit.MINUTES));
         return cacheManager;
     }
     ```

### 7. **JCache (JSR-107)**
   - JCache is a standard API for caching in Java, and Spring Boot supports its use via the `javax.cache` package.
   - You can plug in different caching implementations like Ehcache, Hazelcast, or others that support the JCache API.
   - It’s useful if you want to write vendor-agnostic caching code.

     **Example (JCache Configuration):**
     ```java
     @Cacheable(cacheNames = "books", cacheManager = "jCacheManager")
     public Book findBookByIsbn(String isbn) {
         // fetch book from database
     }
     ```

### 8. **No-Op Cache**
   - The "No-Op" cache is a dummy cache where no actual caching happens.
   - This is useful for testing purposes where you want to disable caching without removing `@Cacheable` annotations.

     **Example (No-Op Cache Configuration):**
     ```yaml
     spring:
       cache:
         type: none
     ```

---

### Key Annotations Used in Spring Boot Caching:
1. **@Cacheable**: Used to indicate that the result of a method should be cached.
   - Example: `@Cacheable("books")`
   
2. **@CacheEvict**: Used to clear the cache for a particular key or all entries.
   - Example: `@CacheEvict(value = "books", allEntries = true)`
   
3. **@CachePut**: Updates the cache with the new result after the method execution.
   - Example: `@CachePut(value = "books", key = "#isbn")`
   
4. **@Caching**: Used to group multiple cache operations like `@Cacheable`, `@CachePut`, and `@CacheEvict`.
   - Example: 
     ```java
     @Caching(evict = { @CacheEvict("books"), @CacheEvict("authors") })
     ```

### Choosing the Right Cache:
- **In-Memory Cache** (Simple Cache, Caffeine) is ideal for single-instance applications.
- **Distributed Cache** (Redis, Hazelcast, Ehcache) is better for multi-instance or microservice-based architectures where you need data to persist across application restarts or across different nodes in a cluster.

What is the significance of the @Autowired annotation in Spring Boot Application?
================================================================================

The `@Autowired` annotation in Spring Boot (and Spring Framework) is used for **Dependency Injection (DI)**, which is a key design principle that allows the Spring container to manage the creation and injection of dependent objects (beans) into a class, without the class needing to explicitly instantiate them. This promotes loose coupling and makes the code more modular, testable, and maintainable.

Here’s the significance of `@Autowired`:

### 1. **Automatic Dependency Injection**
   - When you use `@Autowired`, Spring automatically detects the required bean and injects it into the class where it’s annotated.
   - You don’t need to manually create or initialize the object; Spring takes care of that based on the application's context.
   - This simplifies code by eliminating boilerplate code for creating and managing dependencies.

   **Example:**
   ```java
   @Service
   public class UserService {
   
       @Autowired
       private UserRepository userRepository;  // Automatically injected
   
       public List<User> getAllUsers() {
           return userRepository.findAll();  // No need to instantiate userRepository
       }
   }
   ```

### 2. **Constructor, Setter, or Field Injection**
   The `@Autowired` annotation can be used in different places to inject dependencies.

   - **Constructor Injection (Preferred)**: Dependency is injected through the constructor. This approach is recommended for mandatory dependencies and makes the object immutable after construction.
     
     **Example:**
     ```java
     @Service
     public class UserService {
     
         private final UserRepository userRepository;
     
         @Autowired
         public UserService(UserRepository userRepository) {  // Dependency injected via constructor
             this.userRepository = userRepository;
         }
     }
     ```

   - **Setter Injection**: Dependency is injected via a setter method. This is useful when the dependency is optional or can be changed after object construction.
     
     **Example:**
     ```java
     @Service
     public class UserService {
     
         private UserRepository userRepository;
     
         @Autowired
         public void setUserRepository(UserRepository userRepository) {
             this.userRepository = userRepository;
         }
     }
     ```

   - **Field Injection**: Dependency is injected directly into the field. This is less recommended because it makes unit testing harder (as the field is private and final) and is less flexible than constructor injection.
     
     **Example:**
     ```java
     @Service
     public class UserService {
     
         @Autowired
         private UserRepository userRepository;  // Dependency injected into the field
     }
     ```

### 3. **Handling Multiple Beans**
   If Spring finds multiple beans of the same type, it may cause ambiguity. You can resolve this by:
   - **@Qualifier**: Used alongside `@Autowired` to specify which exact bean to inject if multiple beans of the same type are available.
   - **@Primary**: Marks a bean as the primary candidate when multiple beans are available for injection.

   **Example with @Qualifier:**
   ```java
   @Autowired
   @Qualifier("mySpecialRepository")
   private UserRepository userRepository;
   ```

   **Example with @Primary:**
   ```java
   @Primary
   @Repository
   public class DefaultUserRepository implements UserRepository {
       // Implementation details
   }
   ```

### 4. **Injecting Collections**
   `@Autowired` can also be used to inject collections of beans. Spring will inject all beans of a particular type into a list, set, or other collection.

   **Example:**
   ```java
   @Service
   public class NotificationService {

       @Autowired
       private List<NotificationSender> notificationSenders;  // Injects all NotificationSender beans

       public void sendNotifications() {
           for (NotificationSender sender : notificationSenders) {
               sender.send();
           }
       }
   }
   ```

### 5. **Optional Dependencies**
   You can inject optional dependencies by using `@Autowired(required = false)`. If the bean is not found, Spring will not throw an exception.

   **Example:**
   ```java
   @Autowired(required = false)
   private UserPreferenceService userPreferenceService;  // This bean is optional
   ```

### 6. **Enabling @Autowired**
   The `@Autowired` feature is enabled through component scanning, which is usually done via annotations like `@SpringBootApplication`, `@ComponentScan`, or other stereotype annotations like `@Component`, `@Service`, `@Repository`, etc.

### Summary of `@Autowired` Benefits:
- **Decoupling**: Reduces tight coupling between components, making it easier to test, manage, and scale.
- **Lifecycle Management**: Spring manages the lifecycle of beans, ensuring efficient resource usage.
- **Flexibility**: Provides various ways to inject dependencies, such as field, constructor, and setter-based injection.
- **Easy to Use**: The annotation simplifies the process of dependency injection, avoiding manual bean creation.

How can you handle exception in spring boot application?
========================================================
Handling exceptions in a Spring Boot application is critical for ensuring smooth user experience and proper error management. Spring Boot provides several mechanisms for handling exceptions both globally and locally. Here's an overview of how to handle exceptions in a Spring Boot application:

### 1. **Using `@ExceptionHandler` for Local Exception Handling**
   The `@ExceptionHandler` annotation is used to handle exceptions at the controller level. It allows you to catch specific exceptions in a method and return a custom response.

   **Example:**
   ```java
   @RestController
   public class UserController {

       @GetMapping("/users/{id}")
       public User getUserById(@PathVariable Long id) {
           return userService.findById(id)
                             .orElseThrow(() -> new UserNotFoundException("User not found with id: " + id));
       }

       @ExceptionHandler(UserNotFoundException.class)
       public ResponseEntity<String> handleUserNotFound(UserNotFoundException ex) {
           return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
       }
   }
   ```

   In this example:
   - If `UserNotFoundException` is thrown in the controller method, the `handleUserNotFound` method will handle it and return a `404 Not Found` response with a custom message.

### 2. **Global Exception Handling using `@ControllerAdvice`**
   If you want to handle exceptions across the entire application, you can use `@ControllerAdvice`. This allows you to centralize your exception handling logic and apply it globally.

   **Example:**
   ```java
   @ControllerAdvice
   public class GlobalExceptionHandler {

       @ExceptionHandler(UserNotFoundException.class)
       public ResponseEntity<String> handleUserNotFound(UserNotFoundException ex) {
           return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
       }

       @ExceptionHandler(Exception.class)
       public ResponseEntity<String> handleGlobalException(Exception ex) {
           return new ResponseEntity<>("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
       }
   }
   ```

   - The `@ControllerAdvice` annotated class handles exceptions for all controllers.
   - It can catch specific exceptions like `UserNotFoundException`, and generic exceptions like `Exception`.

### 3. **Using `ResponseStatusException` for Simpler Exception Handling**
   You can throw `ResponseStatusException` directly in your controller or service methods to return specific HTTP status codes along with a custom error message.

   **Example:**
   ```java
   @GetMapping("/users/{id}")
   public User getUserById(@PathVariable Long id) {
       return userService.findById(id)
                         .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found with id: " + id));
   }
   ```

   This approach eliminates the need for creating custom exceptions and `@ExceptionHandler` methods.

### 4. **Custom Exceptions with `@ResponseStatus` Annotation**
   You can define custom exceptions and annotate them with `@ResponseStatus` to automatically map the exception to a specific HTTP status code when thrown.

   **Example:**
   ```java
   @ResponseStatus(HttpStatus.NOT_FOUND)
   public class UserNotFoundException extends RuntimeException {
       public UserNotFoundException(String message) {
           super(message);
       }
   }
   ```

   - When `UserNotFoundException` is thrown, Spring automatically returns a `404 Not Found` response with the provided message.

### 5. **Handling Validation Exceptions**
   When using Spring's validation framework (`@Valid` or `@Validated`), you can catch and handle validation exceptions like `MethodArgumentNotValidException`.

   **Example:**
   ```java
   @PostMapping("/users")
   public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
       return new ResponseEntity<>(userService.save(user), HttpStatus.CREATED);
   }

   @ControllerAdvice
   public class ValidationExceptionHandler {

       @ExceptionHandler(MethodArgumentNotValidException.class)
       public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
           Map<String, String> errors = new HashMap<>();
           ex.getBindingResult().getAllErrors().forEach(error -> {
               String fieldName = ((FieldError) error).getField();
               String errorMessage = error.getDefaultMessage();
               errors.put(fieldName, errorMessage);
           });
           return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
       }
   }
   ```

   - This example catches `MethodArgumentNotValidException`, which is thrown when a validation error occurs (e.g., when creating a new user), and returns a detailed error message for each invalid field.

### 6. **Returning Custom Error Responses using `@ResponseBody`**
   You can customize the error response body by returning a structured object instead of plain text.

   **Example:**
   ```java
   @ExceptionHandler(UserNotFoundException.class)
   @ResponseBody
   public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException ex) {
       ErrorResponse error = new ErrorResponse();
       error.setMessage(ex.getMessage());
       error.setTimestamp(LocalDateTime.now());
       error.setStatus(HttpStatus.NOT_FOUND.value());
       return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
   }

   public class ErrorResponse {
       private String message;
       private LocalDateTime timestamp;
       private int status;

       // getters and setters
   }
   ```

   In this case, a custom `ErrorResponse` object is returned with detailed information like timestamp, status code, and error message.

### 7. **Handling Exceptions in Filters and Interceptors**
   Sometimes, exceptions might be thrown from filters or interceptors (which execute before or after controller methods). These exceptions can also be handled globally in `@ControllerAdvice`.

   Alternatively, you can write custom error handling in the filter itself.

   **Example:**
   ```java
   public class CustomFilter extends OncePerRequestFilter {
   
       @Override
       protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
               throws ServletException, IOException {
           try {
               filterChain.doFilter(request, response);
           } catch (Exception e) {
               response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
               response.getWriter().write("An error occurred in the filter: " + e.getMessage());
           }
       }
   }
   ```

### 8. **Handling Asynchronous Exceptions**
   For exceptions thrown in asynchronous methods (`@Async`), Spring provides `AsyncUncaughtExceptionHandler` to manage uncaught exceptions.

   **Example:**
   ```java
   @Configuration
   public class AsyncConfig implements AsyncConfigurer {

       @Override
       public Executor getAsyncExecutor() {
           return Executors.newCachedThreadPool();
       }

       @Override
       public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
           return new CustomAsyncExceptionHandler();
       }
   }

   public class CustomAsyncExceptionHandler implements AsyncUncaughtExceptionHandler {

       @Override
       public void handleUncaughtException(Throwable ex, Method method, Object... params) {
           System.err.println("Exception in async method: " + ex.getMessage());
       }
   }
   ```

### 9. **Custom Error Pages**
   You can define custom error pages by creating `error.html` in the `src/main/resources/templates/error` directory or by configuring the `ErrorController` interface.

   **Example:**
   ```java
   @Controller
   public class CustomErrorController implements ErrorController {

       @RequestMapping("/error")
       public String handleError() {
           return "error-page";  // Returns a custom error view
       }

       @Override
       public String getErrorPath() {
           return "/error";
       }
   }
   ```

### Summary:
- **@ExceptionHandler**: Handles exceptions in specific controllers.
- **@ControllerAdvice**: Global exception handling for all controllers.
- **ResponseStatusException**: Simplified exception handling with HTTP status codes.
- **@ResponseStatus**: Custom exceptions with automatic HTTP status.
- **Validation Exception Handling**: Handles validation errors.
- **Custom Error Responses**: Structured error handling with detailed response bodies.
- **Asynchronous Exception Handling**: Manage exceptions in `@Async` methods.

These mechanisms together provide a robust and flexible way to manage errors in Spring Boot applications.

Explain the concept of profiles in Spring Boot and how you can use them?
========================================================================
In Spring Boot, **profiles** are a mechanism to manage different configurations for different environments (such as development, testing, production, etc.). By using profiles, you can isolate environment-specific properties or beans and switch between them easily without changing the code.

### Key Concepts of Profiles:
1. **Environment-Specific Configuration**:
   Profiles allow you to define different configurations for various environments. For example, you can have one set of database configurations for development and another for production.

2. **Profile Activation**:
   You can activate a profile when starting a Spring Boot application by specifying it in the environment or in the configuration files.

3. **Profile-Specific Properties Files**:
   Spring Boot can load different property files based on the active profile. For example:
   - `application-dev.properties`: used in the development environment.
   - `application-prod.properties`: used in the production environment.
   The general `application.properties` is used as a fallback for any shared properties across all profiles.

### How to Use Profiles in Spring Boot:

1. **Profile-Specific Properties**:
   You can create different properties files for each profile:
   ```
   src/main/resources/application-dev.properties
   src/main/resources/application-prod.properties
   ```
   When you run the application with a specific profile, Spring Boot automatically loads the corresponding properties file.

2. **Defining Profiles in Code**:
   You can define beans that are specific to certain profiles by using the `@Profile` annotation in your Java classes. For example:
   ```java
   @Configuration
   public class DataSourceConfig {
       
       @Bean
       @Profile("dev")
       public DataSource devDataSource() {
           // return DataSource configured for development
       }

       @Bean
       @Profile("prod")
       public DataSource prodDataSource() {
           // return DataSource configured for production
       }
   }
   ```

3. **Activating Profiles**:
   - **Via Properties File**:
     You can specify the active profile in the `application.properties` file:
     ```properties
     spring.profiles.active=dev
     ```
   - **Via Command Line**:
     You can activate a profile when starting the application using the command line:
     ```bash
     java -jar myapp.jar --spring.profiles.active=prod
     ```
   - **Via Environment Variables**:
     Set the environment variable before running the application:
     ```bash
     export SPRING_PROFILES_ACTIVE=prod
     ```

4. **Multiple Profiles**:
   You can activate multiple profiles at once by separating them with commas:
   ```properties
   spring.profiles.active=dev,logging
   ```

5. **Default Profile**:
   If no profile is explicitly activated, Spring Boot uses the default profile, which can be specified as:
   ```properties
   spring.profiles.default=dev
   ```

### Example Use Case:
You have a Spring Boot application where you want different database configurations for development and production.

**application-dev.properties**:
```properties
spring.datasource.url=jdbc:h2:mem:devdb
spring.datasource.username=sa
spring.datasource.password=
```

**application-prod.properties**:
```properties
spring.datasource.url=jdbc:mysql://prod-db-server/mydb
spring.datasource.username=produser
spring.datasource.password=securepassword
```

**Running the application in development**:
```bash
java -jar myapp.jar --spring.profiles.active=dev
```

By using profiles, you can seamlessly manage environment-specific configurations and isolate logic for different scenarios without changing the core application code.

Why use Spring Boot over Spring Framework?
==========================================
Spring Boot is a framework built on top of the Spring Framework that simplifies the development of Spring applications by removing much of the boilerplate code and configuration required by traditional Spring applications. Here’s why you might choose Spring Boot over the Spring Framework:

### 1. **Auto-Configuration**:
   - **Spring Framework**: Requires significant manual configuration. You need to configure components like the data source, view resolvers, and security manually using XML or Java configuration classes.
   - **Spring Boot**: Provides **auto-configuration**. It automatically configures many Spring components based on the libraries present on the classpath and sensible defaults. This allows you to start a new project quickly without manually specifying every configuration.

   Example: If Spring Boot detects that you have a database driver in your project, it automatically configures a DataSource without needing to set it up manually.

### 2. **Embedded Server**:
   - **Spring Framework**: You need to deploy your application to an external servlet container like Tomcat or Jetty.
   - **Spring Boot**: Comes with an **embedded server** (e.g., Tomcat, Jetty) out-of-the-box. You can run your application as a **standalone JAR** by simply executing it. This removes the need for traditional WAR packaging and external servers.

   Example: You can start a Spring Boot application with the `java -jar` command and it will run the embedded Tomcat server automatically.

### 3. **Convention over Configuration**:
   - **Spring Framework**: Follows a "configuration first" approach, requiring you to configure most aspects of your application explicitly.
   - **Spring Boot**: Follows a "convention over configuration" paradigm, where it provides default configurations that work in most situations, allowing you to focus more on writing business logic rather than configuration. If needed, you can still override these defaults.

### 4. **Starter POMs**:
   - **Spring Framework**: You have to manually specify dependencies for each Spring module, such as Spring MVC, Spring Data, etc.
   - **Spring Boot**: Provides **starter POMs** (project object models) that bundle commonly used dependencies into a single dependency. For example, `spring-boot-starter-web` includes everything you need to build a web application (like Spring MVC, Jackson, and an embedded Tomcat server), reducing the need to manage individual dependencies manually.

   Example: Instead of managing each dependency for a Spring MVC project, you just include:
   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   ```

### 5. **Rapid Application Development**:
   - **Spring Framework**: While powerful, it often requires a lot of configuration setup for even basic applications, which can slow down development.
   - **Spring Boot**: Designed for **rapid application development**. With features like auto-configuration, embedded servers, and starter POMs, you can quickly prototype applications without worrying about detailed setup.

### 6. **Built-in Production-Ready Features**:
   - **Spring Framework**: Requires you to manually configure many production-level features such as monitoring, health checks, and metrics.
   - **Spring Boot**: Includes **production-ready features** out-of-the-box through **Spring Boot Actuator**. Actuator provides endpoints for health checks, metrics, application info, and monitoring that can be easily integrated into your application.

   Example: By adding Spring Boot Actuator, you can monitor your application’s health with no additional configuration:
   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-actuator</artifactId>
   </dependency>
   ```

### 7. **Opinionated Defaults**:
   - **Spring Framework**: Offers flexibility, but with flexibility comes complexity and the need for in-depth knowledge to make the right choices.
   - **Spring Boot**: Provides **opinionated defaults** for most use cases, so developers can follow best practices without having to think about every detail. This makes it ideal for less experienced developers or for projects where you want to get started quickly.

### 8. **Command-Line Interface (CLI)**:
   - **Spring Framework**: Doesn’t have built-in support for CLI tools.
   - **Spring Boot**: Provides a **Command-Line Interface (CLI)** for running and testing Spring Boot applications. You can use it to run Groovy scripts that can auto-wire Spring components without needing full project setup.

   Example: You can write a Groovy script with Spring Boot CLI to quickly spin up a web app without complex setup.

### 9. **Microservices Support**:
   - **Spring Framework**: Supports building large-scale enterprise applications but requires more configuration and setup when building microservices.
   - **Spring Boot**: Naturally suited for **microservices architecture** with features like embedded servers, lightweight packaging (JARs), and easy REST API creation. It also integrates well with cloud-native tools like Spring Cloud, which builds on top of Spring Boot to provide distributed system features like service discovery, circuit breakers, and configuration management.

### 10. **Less Boilerplate Code**:
   - **Spring Framework**: Tends to require more boilerplate code for common tasks, such as setting up data sources or security.
   - **Spring Boot**: Reduces boilerplate code significantly with auto-configuration and starter dependencies, making your codebase cleaner and more maintainable.

### When to Use Spring Boot:
- When you want to quickly build a new application with minimal setup.
- When you want to use microservices or cloud-native architectures.
- When you need an embedded server and want to avoid deploying to an external server.
- When you want to focus on writing business logic without worrying about configuration.

### When to Use the Traditional Spring Framework:
- When you need fine-grained control over every aspect of the application.
- When you are working in a large, pre-existing project that uses traditional Spring configurations.
- When you want to use a specific application server (e.g., deploying to an enterprise server like WebLogic or JBoss) instead of the embedded server.

In summary, **Spring Boot simplifies development** by handling many common configuration and setup tasks for you, whereas **Spring Framework** offers more flexibility and control but requires more configuration and manual setup. For modern applications, especially microservices, Spring Boot is typically the preferred choice.
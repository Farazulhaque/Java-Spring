====================
WHAT IS SPRING BOOT?
====================

Spring Boot is a Java framework that makes it easier to create and run Java applications.

Spring Boot is an open-source Java-based framework used to create stand-alone, production-grade Spring-based applications. It is designed to simplify the development of new Spring applications by providing defaults for configuration and a variety of out-of-the-box functionalities that speed up the development process.

### Key Features of Spring Boot

1. **Auto-Configuration**:
   - Spring Boot can automatically configure your application based on the dependencies you have added to the project. For example, if you include the `spring-boot-starter-web` dependency, Spring Boot will automatically configure a web application with Tomcat and Spring MVC.

2. **Standalone Applications**:
   - Spring Boot applications can be run as standalone applications from the command line using `java -jar`. They come with an embedded web server (such as Tomcat, Jetty, or Undertow), so you don’t need to deploy them to an external server.

3. **Production-Ready Features**:
   - Spring Boot includes features like metrics, health checks, and externalized configuration to help you build and run your applications in production environments.

4. **Opinionated Defaults**:
   - Spring Boot follows an opinionated approach to configuration, providing sensible defaults to reduce the need for manual setup. This helps developers get started quickly.

5. **Spring Boot Starters**:
   - Starters are a set of convenient dependency descriptors you can include in your application. For example, the `spring-boot-starter-data-jpa` starter includes dependencies for Spring Data JPA, Hibernate, and the H2 database.

6. **Spring Boot CLI**:
   - The Spring Boot CLI (Command Line Interface) allows you to run and test Spring Boot applications from the command line. It can be used to quickly prototype with Groovy scripts.

### Benefits of Using Spring Boot

- **Reduced Boilerplate Code**: Spring Boot reduces the amount of boilerplate code required to set up a Spring application.
- **Rapid Development**: The framework’s auto-configuration and starter dependencies help you get started quickly.
- **Microservices Architecture**: Spring Boot is commonly used to develop microservices due to its simplicity and ease of deployment.
- **Embedded Servers**: No need to install or configure an external server; you can run your application with embedded servers like Tomcat, Jetty, or Undertow.
- **Ecosystem Integration**: Seamless integration with the Spring ecosystem and other popular libraries and tools.



============================
WHY SPRING BOOT OVER SPRING?
============================

Spring Boot offers several advantages over the traditional Spring framework, particularly in terms of simplifying and accelerating the development process. Here are the key reasons why developers often choose Spring Boot over Spring:

### 1. **Auto-Configuration**

**Spring Boot**:
- Spring Boot can automatically configure many aspects of your application based on the dependencies included in your project.
- Reduces the need for extensive XML or Java-based configuration, allowing you to get started quickly with minimal setup.

**Traditional Spring**:
- Requires explicit configuration using XML files or Java classes with `@Configuration` annotations.
- More setup and boilerplate code are required to get a basic application running.

### 2. **Embedded Servers**

**Spring Boot**:
- Comes with embedded servers like Tomcat, Jetty, and Undertow.
- Allows you to run applications as standalone jar files using `java -jar`, eliminating the need to deploy to an external application server.

**Traditional Spring**:
- Typically requires deployment to an external application server like Tomcat or Jetty.
- Additional steps are needed to package and deploy the application.

### 3. **Starter Dependencies**

**Spring Boot**:
- Provides starter dependencies (`spring-boot-starter-*`) that aggregate commonly used libraries and frameworks, simplifying dependency management.
- Reduces the need to manually specify versions and compatibility of various dependencies.

**Traditional Spring**:
- Requires manual management of dependencies, including version compatibility.
- Developers need to add and configure each dependency individually.

### 4. **Production-Ready Features**

**Spring Boot**:
- Includes built-in support for monitoring, metrics, health checks, and externalized configuration.
- Provides production-ready features with minimal setup, making it easier to manage and monitor applications in production environments.

**Traditional Spring**:
- Requires additional libraries and configuration to achieve the same level of monitoring and management.
- More manual effort is needed to set up production-ready features.

### 5. **Spring Boot CLI**

**Spring Boot**:
- Offers a Command Line Interface (CLI) that allows you to run and test Spring Boot applications using Groovy scripts.
- Facilitates rapid prototyping and development without the need for a full-fledged Java IDE.

**Traditional Spring**:
- Does not have a dedicated CLI for rapid application development.
- Typically requires a full development environment setup.

### 6. **Simplified Deployment**

**Spring Boot**:
- Simplifies deployment with its embedded servers and single executable JAR/WAR files.
- Supports Docker and cloud-native deployments out-of-the-box, making it easier to containerize and deploy applications in modern cloud environments.

**Traditional Spring**:
- Often involves more complex deployment processes, including packaging and configuring external servers.
- Requires additional setup for containerization and cloud deployments.

### 7. **Microservices Architecture**

**Spring Boot**:
- Well-suited for building microservices due to its lightweight nature, ease of configuration, and built-in support for RESTful services.
- Integrates seamlessly with Spring Cloud, which provides tools for building robust microservices architectures.

**Traditional Spring**:
- Can be used for microservices, but requires more manual configuration and setup.
- Lacks the streamlined approach provided by Spring Boot for quickly setting up and managing microservices.

### Conclusion

Spring Boot is preferred over traditional Spring for its ability to simplify development, configuration, and deployment processes. It reduces boilerplate code, provides sensible defaults, and offers a comprehensive set of tools and features that streamline the creation of production-ready applications. This makes Spring Boot an excellent choice for modern application development, particularly when speed and simplicity are critical.



============================
WORKING OF SPRING BOOT?
============================

Spring Boot starts by scanning the starter dependency in pom.xml
Then download and auto-configure the module included in pom.xml



============================
HOW SPRING BOOT STARTS?
============================

Starts by calling main() method of your main class.
The run() method of SpringApplication is called. This method starts the application by creating an application context and initializing it.
Once the application context is initialises, the run() method starts the application's embedded web server.



============================
TOP SPRING BOOT ANNOTATIONS
============================

@Bean
In Spring Boot, the @Bean annotation is used to declare a method as a bean definition that Spring will manage and create an instance of. Beans are objects that form the backbone of a Spring application and are managed by the Spring IoC (Inversion of Control) container.

@SpringBootApplication: It combines three annotations: 
@Configuration: ,
-> Indicates that the class can be used by the Spring IoC container as a source of bean definitions
-> When you annotate a class with @Configuration, it tells Spring that this class contains one or more methods annotated with @Bean which should be invoked to instantiate and configure new objects (beans) managed by the Spring IoC (Inversion of Control) container.
-> This is particularly useful for defining beans in a centralized way, especially for beans that are complex or need specific construction logic.

@EnableAutoConfiguration: 
-> Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings
-> It simplifies Spring configuration by automatically configuring beans that are likely needed based on the libraries present in the project.
-> For example, if you have the spring-boot-starter-web dependency in your project, @EnableAutoConfiguration will configure necessary beans for a web application, like a DispatcherServlet, a ViewResolver, and more.
-> It reduces the need for explicit bean configuration in many common cases.

@ComponentScan: 
-> Tells Spring to look for other components, configurations, and services in the specified package
-> By default, @ComponentScan scans the package of the class that declares this annotation.
-> You can specify base packages to scan by providing the basePackages attribute.

@Component: 
-> The @Component annotation is used to mark a Java class as a Spring component. Spring will automatically detect these classes through classpath scanning and register them as beans in the application context.
-> It is a generic stereotype for any Spring-managed component. You can use it to annotate classes that perform a variety of tasks in your application, and Spring will recognize and manage these classes as beans.

@Autowired: 
-> The @Autowired annotation in Spring Boot is used to automatically inject dependencies into a Spring-managed bean. This feature is a core part of the Spring Framework's Dependency Injection (DI) and Inversion of Control (IoC) mechanisms.
-> By using this annotation, you let Spring manage the lifecycle and dependency graph of your beans, promoting loose coupling and enhancing testability.

@Service: 
-> The @Service annotation in Spring Boot is used to indicate that a class is a "service" class, which typically contains business logic. It is a specialization of the @Component annotation, which means that the class annotated with @Service is also a Spring bean and will be automatically detected through classpath scanning.

@RestController: 
-> @RestController in Spring Boot is like a special tool we use to create web services, particularly for building APIs (Application Programming Interfaces). It helps us send and receive data between different software systems over the internet.
-> It's used to indicate that the data returned by the methods of the annotated class should be directly written to the HTTP response body as JSON/XML/any other type of response body content instead of relying on a view technology to perform server-side rendering of the output.
-> @RestController is particularly useful when you're building RESTful web services or APIs where the response is often JSON or XML data rather than HTML for human consumption. It saves you from explicitly annotating each method with @ResponseBody in such cases.

@Controller: 
-> The primary purpose of a controller in a Spring MVC application is to handle incoming HTTP requests from clients and generate an appropriate response. These requests typically correspond to user actions, such as clicking a link, submitting a form, or making an AJAX call.
-> Controllers typically contain methods annotated with @RequestMapping (or other variants like @GetMapping, @PostMapping, etc.). These annotations define the URL patterns that the controller method can handle. For example, a method annotated with @GetMapping("/products") would handle GET requests to the "/products" URL.
-> When a request comes in, the DispatcherServlet examines the URL and consults the request mappings defined in the registered controllers. If it finds a matching mapping, it delegates the request to the corresponding controller method for processing.
-> Controller methods typically return a ModelAndView object or a String representing the view name. The model contains data to be displayed by the view, while the view is responsible for rendering the response to the client.
-> In Spring Boot applications, controllers are automatically discovered and registered as beans, thanks to the auto-configuration provided by Spring Boot. You can simply annotate your controller classes with @Controller and define request mappings to handle HTTP requests.

@RequestMapping:
-> @RequestMapping is a Spring annotation used to map web requests to specific handler methods in Spring MVC and Spring WebFlux applications. It is used to define the URL pattern that a controller method will handle. 
-> In Spring Boot, which builds upon the Spring framework, @RequestMapping is commonly used in RESTful web services to define the endpoints of the API.
-> Starting from Spring 4.3, you can use more specific annotations instead of @RequestMapping. For example:
   @GetMapping for GET requests
   @PostMapping for POST requests
   @PutMapping for PUT requests
   @DeleteMapping for DELETE requests

@Repository: 
-> In Spring Framework, @Repository is an annotation used at the class level to indicate that the class provides mechanisms for storage, retrieval, search, update, and delete operations on objects. 
-> It is typically used to annotate classes that access the database or any other type of persistence mechanism.



==================================
WHAT ARE THE SPRING BOOT STARTERS?
==================================

-> Starters are a collection of pre-configured dependencies that make it easier to develop particular kinds of applications.
-> These starters include all of the dependencies, version control, and configurations needed to make certain features of Spring Boot application functional.



=============================================
WHAT ARE THE KEY DEPENDENCIES OF SPRING BOOT?
=============================================

-> spring-boot-starter-parent
-> spring-bbot-maven-plugin
-> spring-boot-starter-test
-> spring-boot-starter-web
-> spring-bbot-starter-security



=============================================
WHAT IS spring-boot-starter-parent?
=============================================

-> Spring Boot Starter Parent is a starter project that provides the default configuration for spring based application.
   - The dependency management feature manages the versions of common dependencies.
   - Provide the default compiler level as Java 1.8 and UTF-8 source encoding.
   - Provides a default configuration for maven plugin.



==================================================
WHAT IS SPRING BBOT CLI AND WHAT ARE ITS BENEFITS?
==================================================

-> Command line tool to create, run and manage spring boot Applications.

spring version
spring help
spring init
spring help init
spring init --list

spring init -d web cli-project



==================
WHAT IS THYMELEAF?
==================

-> Java based server-side templating engine used in Java web applications to render dynamic web pages.



====================================
WHAT IS IOC OR INVERSION OF CONTROL?
====================================

-> Inverting the control of creating object using new keyword to container or framework.



=============================
EXPLAIN SPRING BEAN LIFECYCLE
=============================

-> Bean - Plain Old Java Object
-> Spring Bean lifecycle is maintained by IOC container.
   1. Container gets started
   2. Container creates object of the bean as per request.
   3. Dependencies is created.
   4. Dependencies is injected.
   5. Destroyed when container is closed.
   
In Spring Boot, the `@Bean` annotation is used to declare a method as a bean definition that Spring will manage and create an instance of. Beans are objects that form the backbone of a Spring application and are managed by the Spring IoC (Inversion of Control) container.

When you annotate a method with `@Bean`, Spring will execute that method and register the return value as a bean in the Spring ApplicationContext. These beans are usually used to define configurations, dependencies, and other components in a Spring application.

### Key Features of `@Bean`:
1. **Custom Bean Creation**: It allows you to define your own bean creation logic for objects that are not automatically created by Spring.
2. **Dependency Injection**: Beans can be automatically injected into other beans using annotations like `@Autowired`.
3. **Scope Management**: You can specify the bean’s scope (`singleton`, `prototype`, etc.) using the `@Scope` annotation along with `@Bean`.
4. **Initialization and Destruction Methods**: You can specify methods that should be called after the bean is created or before it is destroyed.

### Example:
```java
@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```
In this example, the method `myService()` is annotated with `@Bean`, meaning that Spring will create and manage an instance of `MyServiceImpl` and make it available as a bean in the application context.

You typically use `@Bean` when you need fine control over how an object is instantiated or when third-party library components need to be integrated into your Spring-managed code.


===========================
INTERNAL WORKING OF HASHMAP
===========================
A **HashMap** in Java is a widely used data structure that stores key-value pairs and provides efficient operations for insertion, deletion, and lookup. Here's a detailed explanation of how it works:

---

### 1. **Basics of HashMap**
- **Key-Value Pair**: Data is stored as a combination of a unique key and its corresponding value.
- **Hashing**: The key is processed through a hash function to calculate a hash code, which determines the index in the underlying data structure.
- **Underlying Data Structure**: Internally, a HashMap uses an **array of buckets** where each bucket holds a linked list (or a tree for optimization).

---

### 2. **Internal Structure**
- **Bucket**: A bucket is a storage location in the array where entries with the same hash code can be stored. Initially, the array size is `16`.
- **Entry**: Each bucket stores objects of type `Map.Entry`, which contain:
  - `key`
  - `value`
  - `hash` (hash code of the key)
  - `next` (reference to the next entry in case of collision)

---

### 3. **Operations**

#### a. **Put (Insertion)**
When you add a key-value pair using `put(key, value)`:
1. **Hash Code Calculation**:
   - A hash function is applied to the key to compute the hash code. 
   - The hash code is further compressed to find the index in the array:  
     `index = (n - 1) & hash` (where `n` is the size of the array).

2. **Bucket Selection**:
   - The computed index determines the bucket.

3. **Collision Handling**:
   - If no entry exists at the bucket, the new entry is added.
   - If an entry already exists, a collision occurs:
     - Java 8+: Uses a linked list initially. If the list becomes too long (threshold = 8), it is converted to a balanced tree (Red-Black Tree) for better performance.
     - Previous versions: Used only linked lists, causing performance degradation for many collisions.

4. **Overwrite**:
   - If the same key already exists, the old value is replaced with the new value.

---

#### b. **Get (Lookup)**
When you fetch a value using `get(key)`:
1. **Hash Code Calculation**:
   - The key's hash code is calculated to determine the bucket index.

2. **Bucket Search**:
   - The bucket is searched sequentially (or in the tree if a tree structure is used) for the entry with the matching key.
   - If found, the corresponding value is returned.

3. **Time Complexity**:
   - Average case: \(O(1)\) for lookup (thanks to hashing and low collision rates).
   - Worst case: \(O(n)\) (if all keys hash to the same bucket, degrading to a linked list).

---

#### c. **Remove (Deletion)**
When you remove an entry using `remove(key)`:
1. **Hash Code Calculation**:
   - The key's hash code is calculated to find the bucket index.

2. **Bucket Update**:
   - The bucket is searched for the key.
   - The entry is removed by updating the linked list/tree structure.

---

### 4. **Key Points**
- **Load Factor**:
  - Determines how full the HashMap can be before resizing (default: 0.75).
  - When the size exceeds `capacity * loadFactor`, the HashMap resizes (doubles the bucket array size) and rehashes all entries.

- **Hash Collision**:
  - Happens when two keys generate the same hash code.
  - Handled using separate chaining (linked list/tree) or open addressing (not used in `HashMap`).

- **Performance**:
  - \(O(1)\) average time for `put()`, `get()`, and `remove()`.
  - \(O(n)\) in the worst case (many collisions).

---

### 5. **Example Code**
```java
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        // Creating a HashMap
        HashMap<Integer, String> map = new HashMap<>();

        // Adding elements
        map.put(1, "One");
        map.put(2, "Two");
        map.put(3, "Three");

        // Fetching a value
        System.out.println("Value for key 2: " + map.get(2)); // Output: Two

        // Removing a key
        map.remove(1);

        // Iterating over the HashMap
        for (Integer key : map.keySet()) {
            System.out.println("Key: " + key + ", Value: " + map.get(key));
        }
    }
}
```

---

### 6. **Improvements in Java 8**
- **Treeify Buckets**:
  - Buckets use trees instead of linked lists when the chain length exceeds 8, reducing worst-case lookup time to \(O(\log n)\).
- **Hash Function**:
  - Improved hashing to reduce collision chances, enhancing performance.

---

### Summary
A **HashMap** is fast and efficient due to its hashing mechanism, but its performance depends on factors like the quality of the hash function, load factor, and collision handling mechanism.

======================
ANONYMOUS INNER CLASS
======================

An **anonymous inner class** in Java is a type of inner class (a class defined within another class) that does not have a name. It is used to define and instantiate a class at the same time. Typically, it is used to create an object with a slight modification of an existing class or interface, without creating a separate named subclass.

### Syntax:
An anonymous inner class is defined and instantiated in a single statement using the `new` keyword.

### Key Features:
1. **No Name:** It has no name, so it cannot be reused elsewhere in the code.
2. **Extends or Implements:** It either extends a class or implements an interface, but not both at the same time.
3. **Single Use:** It is usually used for short tasks, such as defining event handlers, callbacks, or one-off implementations.

### Common Usage:
1. **Extending a Class:**

```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal dog = new Animal() {
            @Override
            void makeSound() {
                System.out.println("Dog barks");
            }
        };
        dog.makeSound(); // Output: Dog barks
    }
}
```

2. **Implementing an Interface:**

```java
interface Greeting {
    void sayHello();
}

public class Main {
    public static void main(String[] args) {
        Greeting greet = new Greeting() {
            @Override
            public void sayHello() {
                System.out.println("Hello, World!");
            }
        };
        greet.sayHello(); // Output: Hello, World!
    }
}
```

3. **Using in Event Handling:**

```java
import javax.swing.*;
import java.awt.event.*;

public class Main {
    public static void main(String[] args) {
        JButton button = new JButton("Click Me");
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("Button clicked!");
            }
        });
    }
}
```

### Benefits:
- **Concise:** Reduces boilerplate code.
- **Encapsulation:** The class is only used in the context where it is created.
- **Flexibility:** Easily override methods for specific use cases.

### Limitations:
1. **No Name:** Cannot be reused outside its scope.
2. **Complexity:** Overuse can make code harder to read and maintain.
3. **Single Instance:** Designed for one-time use only.

Anonymous inner classes are a powerful feature in Java, particularly useful for quick and specific customizations of classes or interfaces.

### **What is the difference between ArrayList and LinkedList in Java?**

#### **Key Differences Between ArrayList and LinkedList**

| Feature                     | **ArrayList**                                                                 | **LinkedList**                                                                 |
|-----------------------------|-------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| **Underlying Data Structure** | Uses a **dynamic array** to store elements.                                    | Uses a **doubly linked list** to store elements.                              |
| **Access Time**              | Fast random access due to index-based access (`O(1)` for `get()` and `set()`). | Sequential access; slower random access (`O(n)` for `get()` and `set()`).     |
| **Insertion/Deletion**       | Slower for insertion/deletion in the middle (`O(n)`), as it requires shifting elements. | Faster for insertion/deletion in the middle (`O(1)`), no shifting required.   |
| **Memory Usage**             | Requires less memory overhead.                                                | Requires more memory due to storing node pointers (next and previous).        |
| **Iterating Elements**       | Faster for simple iteration due to contiguous memory storage.                  | Slightly slower for iteration due to pointer chasing in the linked structure. |
| **Best Use Case**            | Best when frequent access or modification of elements is needed.               | Best when frequent insertions and deletions occur.                            |
| **Implementation**           | Part of the `java.util` package, backed by an array.                          | Part of the `java.util` package, backed by a doubly linked list.              |

#### **When to Use Which?**
- **Use ArrayList** if your application involves **frequent read operations** and less modification (e.g., accessing elements by index).
- **Use LinkedList** if your application involves **frequent insertions and deletions**, especially in the middle of the list.

### **What is the difference between ConcurrentHashMap and HashMap in Java?**

#### **Key Differences Between ConcurrentHashMap and HashMap**

| Feature                      | **HashMap**                                                                                   | **ConcurrentHashMap**                                                                            |
|------------------------------|-----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| **Thread Safety**            | Not thread-safe. Needs external synchronization for thread-safe operations.                   | Thread-safe. Designed for concurrent access by multiple threads without the need for external synchronization. |
| **Concurrency Level**        | Does not support concurrent modifications by multiple threads.                                | Allows concurrent modifications by multiple threads with minimal performance impact.           |
| **Null Keys/Values**         | Allows one `null` key and multiple `null` values.                                             | Does not allow `null` keys or `null` values.                                                   |
| **Performance**              | Faster for single-threaded operations due to no synchronization overhead.                     | Slower than HashMap in a single-threaded context due to internal synchronization.              |
| **Synchronization Mechanism**| No built-in synchronization.                                                                  | Uses **segment locking** (in older versions) or a highly optimized lock-free mechanism (Java 8 and later). |
| **Iteration During Modification** | Not fail-safe; `ConcurrentModificationException` may occur if modified during iteration. | Fail-safe to an extent; reflects changes made by other threads during iteration.               |
| **Use Case**                 | Best for single-threaded applications or when synchronization is managed externally.          | Best for multi-threaded applications requiring high concurrency with thread safety.            |

#### **When to Use Which?**
- **Use HashMap** in **single-threaded applications** or when external synchronization (like `synchronized` blocks) can be safely applied.
- **Use ConcurrentHashMap** in **multi-threaded applications** where multiple threads access and modify the map concurrently, and you need built-in thread safety with good performance.


### **Intermediate-Level Java Interview Questions and Answers**

#### **1. What is the difference between `final`, `finally`, and `finalize()` in Java?**
- **`final`**: 
  - A keyword used to declare constants, prevent method overriding, or inheritance.
  - Examples: 
    ```java
    final int x = 10; // Constant
    final class MyClass {} // Cannot be subclassed
    ```
- **`finally`**: 
  - A block used in exception handling to execute code regardless of an exception being thrown.
  - Example: 
    ```java
    try {
        int data = 10 / 0;
    } catch (ArithmeticException e) {
        System.out.println("Exception caught");
    } finally {
        System.out.println("Finally block executed");
    }
    ```
- **`finalize()`**: 
  - A method in the `Object` class used for cleanup before an object is garbage collected. Rarely used.
  - Example: 
    ```java
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Object is being garbage collected");
    }
    ```

---

#### **2. How does `HashMap` work internally in Java?**
- **Internal Structure**:
  - Uses a combination of an **array** and **linked list** (or **tree** since Java 8) for storing key-value pairs.
  - Keys are hashed to determine the index in the internal array.
- **Process**:
  - **Put** operation: 
    - Computes the hashcode of the key, determines the bucket index, and stores the entry.
    - If a collision occurs, entries are linked in a list or converted to a tree.
  - **Get** operation:
    - Computes the hashcode of the key, navigates to the bucket, and compares keys using `equals()` to retrieve the value.

---

#### **3. What is the difference between `ArrayList` and `Vector`?**
| Feature              | **ArrayList**                                      | **Vector**                                       |
|----------------------|---------------------------------------------------|-------------------------------------------------|
| **Thread Safety**     | Not thread-safe. Needs external synchronization.  | Thread-safe. All methods are synchronized.      |
| **Performance**       | Faster, no synchronization overhead.              | Slower due to synchronization overhead.         |
| **Growth Mechanism**  | Increases by 50% when full.                       | Doubles its size when full.                     |
| **Use Case**          | Best for single-threaded applications.            | Best for multi-threaded applications (legacy).  |

---

#### **4. What is the difference between `abstract` class and `interface` in Java?**
| Feature                  | **Abstract Class**                                     | **Interface**                                                 |
|--------------------------|-------------------------------------------------------|--------------------------------------------------------------|
| **Purpose**               | Used to provide partial abstraction and base class.   | Used to achieve full abstraction and define contracts.        |
| **Methods**               | Can have abstract and concrete methods.              | All methods are abstract (Java 7). Default and static methods (Java 8+). |
| **Fields**                | Can have instance variables.                         | Can only have `public static final` constants.                |
| **Inheritance**           | Supports single inheritance.                         | Supports multiple inheritance.                                |
| **Use Case**              | Use when a class shares a common base behavior.       | Use to define a contract for unrelated classes.               |

---

#### **5. Explain `volatile` and `synchronized` keywords.**
- **`volatile`**:
  - Ensures that changes to a variable are immediately visible to all threads.
  - Prevents the compiler and JVM from caching the variable.
  - Example:
    ```java
    private volatile boolean flag = true;
    ```
- **`synchronized`**:
  - Ensures mutual exclusion, allowing only one thread to access a block or method at a time.
  - Can synchronize methods or blocks.
  - Example:
    ```java
    synchronized void increment() {
        count++;
    }
    ```

---

#### **6. What is the difference between `String`, `StringBuilder`, and `StringBuffer`?**
| Feature              | **String**                      | **StringBuilder**                  | **StringBuffer**                  |
|----------------------|----------------------------------|------------------------------------|-----------------------------------|
| **Mutability**        | Immutable                      | Mutable                           | Mutable                          |
| **Thread Safety**     | Not thread-safe                | Not thread-safe                   | Thread-safe                      |
| **Performance**       | Slower for modifications       | Faster than `StringBuffer`         | Slower due to synchronization    |
| **Use Case**          | For fixed or unchanging data.  | For single-threaded scenarios.    | For multi-threaded scenarios.    |

---

#### **7. What is the difference between `Comparable` and `Comparator`?**
| Feature               | **Comparable**                      | **Comparator**                        |
|-----------------------|-------------------------------------|---------------------------------------|
| **Package**            | `java.lang`                       | `java.util`                          |
| **Sorting Logic**      | Natural ordering (implemented within the object). | Custom ordering (defined externally). |
| **Method**             | `compareTo(Object o)`             | `compare(Object o1, Object o2)`      |
| **Usage**              | Implemented by the class being sorted. | Implemented as a separate class.      |
| **Example**            | Sorting by a single property.      | Sorting by multiple properties.       |

In Java, both `Comparable` and `Comparator` are interfaces used to compare objects and determine their natural order, typically for sorting. However, they serve different purposes and are used in distinct scenarios.

---

### **1. `Comparable` Interface**

The `Comparable` interface is used to define the natural ordering of objects of a class. A class implements this interface to specify how its instances should be compared.

#### **Key Features**
- Defined in `java.lang`.
- Has a single method: 
  ```java
  int compareTo(T o);
  ```
- Used to define a class's **default or natural ordering**.

#### **Example**
```java
import java.util.*;

class Student implements Comparable<Student> {
    private int id;
    private String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public int compareTo(Student other) {
        // Natural order by ID
        return this.id - other.id;
    }

    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "'}";
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(3, "Alice"));
        students.add(new Student(1, "Bob"));
        students.add(new Student(2, "Charlie"));

        Collections.sort(students);

        System.out.println("Sorted by ID:");
        for (Student student : students) {
            System.out.println(student);
        }
    }
}
```

#### **Output**
```
Sorted by ID:
Student{id=1, name='Bob'}
Student{id=2, name='Charlie'}
Student{id=3, name='Alice'}
```

---

### **2. `Comparator` Interface**

The `Comparator` interface is used to define custom sorting logic, independent of the class's natural order.

#### **Key Features**
- Defined in `java.util`.
- Has two main methods (Java 8+ supports lambda expressions for concise implementation):
  ```java
  int compare(T o1, T o2);
  boolean equals(Object obj); // Optional
  ```
- Can create **multiple sorting logics** for a class.

#### **Example**
```java
import java.util.*;

class Student {
    private int id;
    private String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "'}";
    }
}

class NameComparator implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.getName().compareTo(s2.getName());
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(3, "Alice"));
        students.add(new Student(1, "Bob"));
        students.add(new Student(2, "Charlie"));

        // Sort by Name using NameComparator
        Collections.sort(students, new NameComparator());

        System.out.println("Sorted by Name:");
        for (Student student : students) {
            System.out.println(student);
        }
    }
}
```

#### **Output**
```
Sorted by Name:
Student{id=3, name='Alice'}
Student{id=1, name='Bob'}
Student{id=2, name='Charlie'}
```

---

### **Differences Between `Comparable` and `Comparator`**

| Feature               | `Comparable`                            | `Comparator`                           |
|-----------------------|------------------------------------------|----------------------------------------|
| **Purpose**           | Natural ordering of class objects.       | Custom ordering of class objects.      |
| **Location**          | Implemented in the class itself.         | Defined in a separate class or inline. |
| **Method**            | `compareTo(Object o)`                   | `compare(Object o1, Object o2)`        |
| **Single/Multiple**   | Only one sorting logic per class.         | Allows multiple sorting logics.        |
| **Usage**             | Implements `Comparable` interface.       | Implements `Comparator` interface.     |

---

### **When to Use**

- Use `Comparable` if:
  - A single, natural order is enough.
  - The comparison logic is intrinsic to the object (e.g., ordering students by ID).

- Use `Comparator` if:
  - Different sorting criteria are required (e.g., sorting students by name, then by ID).
  - The class can't be modified (e.g., you want to sort `String` objects by length).

---

### **Java 8 Enhancements**
With Java 8, you can use lambda expressions to simplify `Comparator` usage:
```java
students.sort((s1, s2) -> s1.getName().compareTo(s2.getName()));
```

Or use built-in methods like `Comparator.comparing`:
```java
students.sort(Comparator.comparing(Student::getName));
```

---

#### **8. Explain the working of a `ThreadPoolExecutor`.**
- **Definition**: A `ThreadPoolExecutor` manages a pool of worker threads, reusing them to execute tasks efficiently.
- **Core Concepts**:
  - **Core Pool Size**: Minimum number of threads to keep alive.
  - **Maximum Pool Size**: Maximum number of threads allowed.
  - **Queue**: Holds tasks waiting to be executed.
  - **Rejection Policy**: Determines what happens when the queue is full.
- **Example**:
  ```java
  ExecutorService executor = new ThreadPoolExecutor(2, 5, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<>());
  executor.execute(() -> System.out.println("Task executed"));
  executor.shutdown();
  ```

---

#### **9. How does `Garbage Collection` work in Java?**
- **Purpose**: Reclaims memory occupied by objects that are no longer reachable.
- **Steps**:
  1. **Mark**: Identifies objects that are reachable.
  2. **Sweep**: Reclaims memory occupied by unreachable objects.
- **Garbage Collectors**:
  - **Serial GC**: Single-threaded collector.
  - **Parallel GC**: Multi-threaded collector.
  - **G1 GC**: Low-latency garbage collector.
  - **ZGC/Shenandoah**: Ultra-low-latency collectors (Java 11+).
- **Triggers**:
  - JVM decides when to invoke GC based on memory pressure.

---

#### **10. What is the difference between `Checked` and `Unchecked` exceptions?**
| Feature                   | **Checked Exception**                       | **Unchecked Exception**                     |
|---------------------------|---------------------------------------------|---------------------------------------------|
| **Definition**             | Exceptions checked at compile time.        | Exceptions checked at runtime.              |
| **Examples**               | `IOException`, `SQLException`.             | `NullPointerException`, `ArithmeticException`. |
| **Handling**               | Must be declared or handled using `try-catch`. | Optional to handle.                         |

--- 

These questions cover both conceptual and practical aspects of intermediate Java programming, helping candidates demonstrate their understanding of Java’s core and advanced features.
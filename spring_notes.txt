What is spring?
Dependency Injection framework to make java application loosely coupled.
makes it easy to develop javaEE application

What is Dependency Injection?
It is Design pattern. 
It makes our application loosely coupled.

Inversion Of Control?
It creates the object in runtime and provide the object using Dependency Injection.

Spring Modules?
- Spring Core - Core, Beans, Context, spEL -> provides DI, IOC -> Dependency to add spring-core, spring-context
- AOP
- Data Access/ Integration - JDBC, ORM, JMS, OXM -> we can use hibernate or jpa using ORM
- Spring Web - Web, Servlet

Spring IOC Container?
Responsible for object creation, hold object in memory, inject one object inside another object.
Responsible for lifecycle of object from creation to destruction.
Using Beans and xml Configuration file.

ApplicationContext extends BeanFactory - Interface that represents IOC Container
ClasspathXMLApplicationContext - search for the xml Configuration in the java classpath -- MOST USED
AnnotationConfigApplicationContext - search for bean where we have used annotation

Beans - Java Class that we provide to xml file to create object of class and follow lifecycle of object creation to destruction

Dependency Injection can be done in two ways--
Setter Injection
Constructor Injection

Data Types that supports Dependency Injection
- Primitive Data Types
- Collection Types - List, Set, Map and Properties
- Reference Data Types - Other class object

How to inject Dependency Injection?
Using property file xml 
<beans><bean class="com.example.Student" name="st1"> <property name="studentId"><value>Faraz</value></property></bean></beans>

Lifecycle of Spring Bean-
public void init() - initialisation code, config, connecting db
public void destroy() - cleanup code

Create object, instatiate object, call init(), read and use the bean, call destroy()

Autowiring - 
Spring container inject the dependency automatically.
Using @Autowired annotation

@Qualifier Annotation - 
It is used to specify the name of the bean that we want to use.

@Component Annotation - 
Spring will create the object of that particular class automatically. We can provide name of the bean in @Component("Name")

@Value Annotation - 
Populate the property value on spring startup.

Spring Beaan Scope - 
Singleton - Default - Only one object has been created by spring and we use that object anytime we want to use the object
Prototype - Everytime new object has been created whenever we call
request 
session
globalsession

@Scaope annotation used with only @Component annotation -> Define scope of bean @Scope("prototype")

@Configuration -> To handle the configuration using java
@ComponentScan -> provide basePackages so that spring will scan that package and create the bean of any class that have @Component / @Bean annotation.

@Bean -> The object is provided to IOC container to use in future.

If using @Bean annotation then we dont have to use @ComponentScan

======================================================================

Spring JDBC
-----------
We can connect with database and execute query using spring jdbc.

It provides JdbcTemplate to perform all the important operation using methods provided by the class.



Spring ORM (Object Relational Mapping)
--------------------------------------
HibernateTemplate class - save(), update(), insert(), get(), loadAll() -> SessionFactory -> LocalSessionFactory -> DataSource




@Entity 
@Table -> Treat the class as database Table

=====================================================================

Why spring security is needed at first place in your application?
-------------------------------------------------------------------
Spring Security is essential in an application for several reasons:

### 1. **Authentication**:
   - **User Verification**: Spring Security provides robust mechanisms for authenticating users. It supports various authentication methods such as form-based login, HTTP Basic authentication, and OAuth2, ensuring that only legitimate users can access the application.

### 2. **Authorization**:
   - **Access Control**: It allows fine-grained control over which users or roles can access certain parts of the application. This helps in enforcing rules like "only admins can delete records" or "only authenticated users can view this page."

### 3. **Protection Against Common Vulnerabilities**:
   - **CSRF Protection**: Cross-Site Request Forgery (CSRF) is a common web application vulnerability. Spring Security automatically includes CSRF protection mechanisms to prevent unauthorized commands being transmitted from a user that the web application trusts.
   - **XSS Protection**: It helps prevent Cross-Site Scripting (XSS) attacks by sanitizing inputs and outputs, ensuring that malicious scripts cannot be executed in the user's browser.
   - **Clickjacking Protection**: It provides defense against clickjacking attacks by allowing the application to control how its pages are displayed in iframes.

### 4. **Session Management**:
   - **Session Fixation Protection**: Spring Security helps mitigate session fixation attacks, where attackers attempt to take over a user's session.
   - **Concurrent Session Control**: It can limit the number of sessions a user can have open simultaneously, which is useful for sensitive applications.

### 5. **Customizable Security**:
   - **Extensible Framework**: Spring Security is highly customizable, allowing developers to define custom security rules, authentication providers, and even integrate with other security frameworks or services.

### 6. **Ease of Integration**:
   - **Spring Ecosystem**: Since Spring Security is part of the Spring ecosystem, it integrates seamlessly with other Spring modules, making it easier to build secure, enterprise-grade applications.

### 7. **Compliance and Auditing**:
   - **Audit Trails**: It helps in keeping track of security-related events such as login attempts, role changes, and unauthorized access attempts, which is crucial for compliance and auditing purposes.

Overall, Spring Security provides a comprehensive and customizable security framework that helps protect applications against a wide range of security threats, ensuring that sensitive data and operations are secure.

How Spring Security is used to secure your application at a high level?
-----------------------------------------------------------------------
Spring Security is used to secure applications at a high level through several key mechanisms:

### 1. **Authentication**:
   - **User Authentication**: Spring Security handles the process of authenticating users when they attempt to log in. This is typically done by comparing the user's credentials (such as username and password) against a stored user database (like in-memory, database-backed, LDAP, etc.).
   - **Integration with OAuth2/OpenID Connect**: For applications requiring integration with third-party identity providers (e.g., Google, Facebook), Spring Security can manage OAuth2 and OpenID Connect authentication.

### 2. **Authorization**:
   - **Role-Based Access Control (RBAC)**: After authentication, Spring Security determines what resources or actions the authenticated user is allowed to access based on their roles or authorities. This is done using annotations like `@PreAuthorize`, `@Secured`, or in the security configuration through URL-based restrictions.
   - **Method-Level Security**: Spring Security allows you to apply security at the method level using annotations, ensuring that sensitive business logic can only be accessed by users with the appropriate permissions.

### 3. **Security Configuration**:
   - **HTTP Security**: Spring Security provides a powerful DSL to configure security policies on HTTP requests. For example, you can specify which endpoints require authentication, configure form login, enable HTTPS, and define CORS policies.
   - **Security Filters**: The core of Spring Security is a chain of filters that intercept incoming requests. These filters handle everything from authentication to authorization, CSRF protection, session management, and more.

### 4. **Session Management**:
   - **Session Fixation Protection**: By default, Spring Security helps protect against session fixation attacks by creating a new session ID upon successful login.
   - **Concurrent Session Control**: You can configure Spring Security to control the number of sessions a user can have simultaneously, and decide how to handle session timeouts and expirations.

### 5. **CSRF Protection**:
   - **Cross-Site Request Forgery (CSRF)**: Spring Security automatically includes CSRF tokens in forms and verifies these tokens on submission to prevent unauthorized commands being sent by malicious users or scripts.

### 6. **Password Management**:
   - **Password Encoding**: Spring Security provides utilities for securely hashing and storing passwords using modern algorithms like bcrypt. It also supports password policies, such as requiring strong passwords.

### 7. **Security Context**:
   - **SecurityContextHolder**: Spring Security uses `SecurityContextHolder` to store authentication details (like user information) for the current user session. This context can be accessed throughout the application, enabling security checks and decisions to be made.

### 8. **Custom Authentication and Authorization**:
   - **Custom Authentication Providers**: If the standard authentication mechanisms don't fit your needs, Spring Security allows you to create custom authentication providers to validate users against any custom logic or external system.
   - **Custom Filters**: You can define custom security filters to implement specific security checks or modify the security flow.

### 9. **Audit and Logging**:
   - **Event Logging**: Spring Security can log security events such as authentication failures, successful logins, and access denials. This is useful for auditing and monitoring potential security breaches.

### 10. **Integration with Spring Boot**:
   - **Auto-Configuration**: In Spring Boot applications, Spring Security is auto-configured, meaning that with minimal setup, you get a secure application out of the box. The defaults are secure, but you can override them to meet your specific needs.

At a high level, Spring Security is embedded throughout the application lifecycle, from intercepting requests to enforcing security policies, authenticating users, authorizing actions, and protecting against common security threats. This integrated approach ensures that the application is secured comprehensively and consistently.

Types of Authentication?
------------------------
Authentication is the process of verifying the identity of a user or system. There are several types of authentication methods that can be implemented depending on the security requirements of an application. Here are some common types:

### 1. **Password-Based Authentication**
   - **Description**: This is the most common form of authentication where users provide a username and password to gain access. The password is typically stored in a hashed format in the database.
   - **Examples**: Logging into a website with a username and password.

### 2. **Multi-Factor Authentication (MFA)**
   - **Description**: MFA requires two or more verification factors to authenticate a user. It adds an extra layer of security beyond just a password.
   - **Factors**:
     - **Something you know**: A password or PIN.
     - **Something you have**: A security token, mobile phone, or smart card.
     - **Something you are**: Biometrics like fingerprints, facial recognition, or iris scans.
   - **Examples**: A banking app that requires a password and a one-time code sent to your mobile device.

### 3. **Token-Based Authentication**
   - **Description**: After the initial login, the server generates a token (like JWT - JSON Web Token) and sends it to the client. The client stores this token and sends it with subsequent requests. The server validates the token to authenticate the user.
   - **Examples**: APIs using JWT tokens for authentication, OAuth2 tokens.

### 4. **Certificate-Based Authentication**
   - **Description**: This method uses digital certificates to identify and authenticate a user or device. A certificate is issued by a trusted certificate authority (CA) and is used in scenarios requiring high security.
   - **Examples**: SSL/TLS client certificates used in VPN connections or secure websites.

### 5. **Biometric Authentication**
   - **Description**: This form of authentication uses unique biological characteristics of the user for verification. It's considered very secure because it’s difficult to replicate biological data.
   - **Examples**: Fingerprint scanning, facial recognition, voice recognition, or retina scanning.

### 6. **One-Time Password (OTP) Authentication**
   - **Description**: OT passwords are valid for only one login session or transaction. They are typically sent to the user’s mobile phone or email and must be entered within a short time frame.
   - **Examples**: SMS-based OTPs for online banking transactions, Google Authenticator codes.

### 7. **Single Sign-On (SSO)**
   - **Description**: SSO allows users to log in once and gain access to multiple related systems without having to log in again for each system. It typically uses protocols like SAML, OAuth, or OpenID Connect.
   - **Examples**: Logging into a corporate network and automatically gaining access to multiple enterprise applications.

### 8. **Social Authentication**
   - **Description**: Users can log into a third-party application using their credentials from a social networking service like Facebook, Google, or Twitter. This is usually implemented using OAuth2.
   - **Examples**: Logging into a website using your Google or Facebook account.

### 9. **Risk-Based Authentication (Adaptive Authentication)**
   - **Description**: This dynamic authentication method evaluates the risk associated with a login attempt based on factors like location, device, behavior patterns, and more. Based on the risk, it may require additional verification.
   - **Examples**: A bank requiring additional verification if a login is attempted from a new device or unusual location.

### 10. **Challenge-Response Authentication**
   - **Description**: In this method, the user is presented with a challenge (usually a question or an image) that they must respond to correctly to authenticate.
   - **Examples**: Security questions, CAPTCHA.

### 11. **Public Key Authentication**
   - **Description**: In public key authentication, a user’s identity is verified using a pair of cryptographic keys: a public key and a private key. The user signs a message with their private key, and the server verifies it using the user's public key.
   - **Examples**: SSH key-based authentication in server access.

### 12. **Kerberos Authentication**
   - **Description**: Kerberos is a network authentication protocol designed to provide strong authentication for client-server applications. It uses secret-key cryptography and a trusted third party (a Key Distribution Center).
   - **Examples**: Authentication in Windows domains.

Each of these methods can be used independently or in combination to enhance the security of an application, depending on the sensitivity of the data and the security requirements.

What are the core concepts of spring security?
----------------------------------------------
Spring Security is a powerful and flexible security framework that provides authentication, authorization, and other security-related features for Java applications. The core concepts of Spring Security are:

### 1. **Security Context**
   - **SecurityContextHolder**: This is the central place where Spring Security stores details about the current security context of the application, including authentication details. It is accessible throughout the application, allowing you to retrieve information about the current user.
   - **Authentication**: The `Authentication` object stored in the `SecurityContext` represents the currently authenticated user. It contains details like the username, password, granted authorities (roles), and other credentials.

### 2. **Authentication**
   - **AuthenticationManager**: This is the core interface responsible for processing authentication requests. It delegates to one or more `AuthenticationProvider` instances to validate user credentials.
   - **AuthenticationProvider**: An `AuthenticationProvider` is responsible for authenticating a user with a specific type of credentials (e.g., username/password, OAuth token). Multiple providers can be chained to support different authentication mechanisms.

### 3. **Authorization**
   - **GrantedAuthority**: Represents an authority or role that is granted to the user. These authorities determine what actions the user is allowed to perform within the application.
   - **AccessDecisionManager**: This is responsible for making final access control decisions. It works with `AccessDecisionVoter` objects to evaluate if a user has the necessary permissions to access a specific resource or perform an action.

### 4. **Security Filters**
   - **Filter Chain**: Spring Security uses a series of filters to process security logic. Each filter performs a specific security function, such as authentication, authorization, session management, or CSRF protection. The filters are organized into a chain that intercepts HTTP requests before they reach the application’s controllers.
   - **UsernamePasswordAuthenticationFilter**: This filter is responsible for processing login requests containing username and password.
   - **BasicAuthenticationFilter**: This filter handles HTTP Basic authentication, where the user's credentials are sent with every request in an HTTP header.

### 5. **Security Configuration**
   - **WebSecurityConfigurerAdapter**: This is a base class used to configure security settings in a Spring application. It provides methods to customize authentication, authorization, HTTP security, and more.
   - **HttpSecurity**: A fluent API provided by Spring Security to configure security settings for HTTP requests, such as defining URL patterns that require authentication, configuring form login, CSRF protection, and more.
   - **Global Method Security**: This allows you to apply security constraints at the method level using annotations like `@Secured`, `@PreAuthorize`, and `@RolesAllowed`.

### 6. **UserDetails and UserDetailsService**
   - **UserDetails**: This interface represents the user’s core information, including username, password, and authorities. It is a central part of the authentication process.
   - **UserDetailsService**: This service is responsible for retrieving the `UserDetails` object based on the provided username during the authentication process.

### 7. **Password Management**
   - **PasswordEncoder**: This interface defines how passwords are encoded and verified in Spring Security. Implementations like `BCryptPasswordEncoder` provide secure password hashing.
   - **Password Storage**: Spring Security encourages storing passwords in a hashed format, not in plain text, to enhance security.

### 8. **Session Management**
   - **SessionManagementFilter**: This filter is responsible for managing user sessions, including protecting against session fixation attacks and controlling the number of concurrent sessions a user can have.
   - **Session Timeout and Invalid Sessions**: You can configure session timeout policies and how to handle invalid sessions (e.g., redirecting to the login page).

### 9. **CSRF Protection**
   - **CsrfFilter**: This filter adds CSRF (Cross-Site Request Forgery) protection to the application by generating and validating CSRF tokens in forms and requests.
   - **CSRF Token**: A unique token that is generated for each session and must be included in forms and requests to validate that the request comes from an authenticated user.

### 10. **Security Expressions**
   - **@PreAuthorize, @PostAuthorize**: These annotations allow you to apply security constraints using SpEL (Spring Expression Language) expressions. For example, `@PreAuthorize("hasRole('ADMIN')")` restricts access to methods based on the user's role.
   - **Web Expression Language**: Used in `HttpSecurity` configurations to define access control rules, such as `hasRole('USER')` or `permitAll()`.

### 11. **Remember-Me Authentication**
   - **Remember-Me Cookie**: This feature allows users to stay logged in between sessions by storing a special token in a cookie. When the user returns, the token is used to authenticate them automatically.
   - **RememberMeAuthenticationFilter**: The filter responsible for checking the remember-me token in requests and automatically authenticating the user if the token is valid.

### 12. **Social Authentication**
   - **OAuth2 and OpenID Connect**: Spring Security provides support for integrating with external identity providers (e.g., Google, Facebook) using OAuth2 and OpenID Connect, allowing users to log in with their social media accounts.

### 13. **Custom Security**
   - **Custom Filters**: You can create custom filters to add specific security logic to your application.
   - **Custom Authentication and Authorization**: You can implement custom `AuthenticationProvider` and `AccessDecisionVoter` classes to meet unique security requirements.

These core concepts form the foundation of Spring Security, allowing developers to build secure applications by addressing authentication, authorization, session management, and protection against common security threats.

Authentication -> uthorization -> Principle -> Granted Authority -> Roles
Role -> Group of authorities
authorities -> Group of permissions

How is spring security intercepting your requests?
--------------------------------------------------
Spring Security intercepts requests in a Spring application by using a chain of security filters that process incoming HTTP requests before they reach the application’s controllers or other processing logic. Here's how this interception works:

### 1. **DelegatingFilterProxy**
   - **Integration with Servlet Container**: The Spring Security filter chain is registered with the servlet container (like Tomcat) using a `DelegatingFilterProxy`. This proxy acts as a bridge between the servlet container and the Spring-managed security filters.
   - **Filter Invocation**: When a request comes in, the servlet container passes it to the `DelegatingFilterProxy`, which in turn delegates the request to the Spring Security filter chain.

### 2. **Security Filter Chain**
   - **FilterChainProxy**: The `FilterChainProxy` is the core component that manages the security filter chain. It delegates the request to the appropriate set of security filters based on the URL pattern matching.
   - **Order of Filters**: The security filters are ordered and executed in sequence. Each filter has a specific responsibility, such as authentication, authorization, session management, CSRF protection, etc.

### 3. **Key Filters in the Chain**
   - **Security Filters**: Some of the key filters in the Spring Security filter chain include:
     - **`UsernamePasswordAuthenticationFilter`**: Handles form-based login requests, authenticating users based on submitted credentials.
     - **`BasicAuthenticationFilter`**: Processes HTTP Basic authentication headers to authenticate users.
     - **`CsrfFilter`**: Adds and validates CSRF tokens to protect against CSRF attacks.
     - **`ExceptionTranslationFilter`**: Handles exceptions related to security, such as access denied or authentication failures, and translates them into appropriate HTTP responses.
     - **`FilterSecurityInterceptor`**: This is the last filter in the chain that performs authorization checks based on the authenticated user's roles and the requested URL.
     - **`SecurityContextPersistenceFilter`**: Manages the `SecurityContext`, which holds the authentication information for the request, storing it in the `SecurityContextHolder`.
     - **`AnonymousAuthenticationFilter`**: Provides a default authentication object for requests where no user is authenticated, allowing anonymous access to specified resources.

### 4. **Processing the Request**
   - **Filter Execution**: As the request passes through the security filter chain, each filter performs its function. For example, the authentication filter checks if the user is logged in, and the authorization filter checks if the user has the necessary permissions to access the requested resource.
   - **Decision Making**: If a filter decides that the request should not proceed (e.g., due to failed authentication or lack of permissions), it can block the request and send an appropriate response (like a redirect to a login page or a 403 Forbidden status).

### 5. **Final Destination**
   - **Controller Access**: If all security checks are passed, the request reaches the application's controllers or other processing logic. The controller can then handle the request as usual, with the knowledge that it has passed all security checks.

### 6. **Customizing the Filter Chain**
   - **Custom Filters**: You can add custom filters to the chain by configuring them in the security configuration. This allows you to introduce custom security logic or modify the behavior of existing filters.
   - **Ordering**: The order of filters in the chain is crucial, as it determines the flow of security processing. Spring Security provides options to customize this order to fit specific security needs.

### 7. **Security Configuration**
   - **HttpSecurity Configuration**: In a Spring Boot application, you typically configure the security filter chain in a class that extends `WebSecurityConfigurerAdapter` (or by using the newer `SecurityFilterChain` bean). This is where you define which filters to use, how URLs should be secured, and which authentication mechanisms to apply.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/public/**").permitAll() // Allow public access
            .anyRequest().authenticated()          // All other requests require authentication
            .and()
        .formLogin()                               // Enable form-based login
            .loginPage("/login")                   // Custom login page
            .permitAll()
            .and()
        .logout()
            .permitAll();
}
```

### 8. **Outcome**
   - **Authenticated Request**: If the request is authenticated and authorized, it is passed through to the application’s business logic.
   - **Blocked Request**: If the request fails any of the security checks, an appropriate error response is sent back, such as a redirect to the login page, or an error page indicating access is denied.

In summary, Spring Security intercepts and processes requests using a well-defined chain of filters that apply authentication, authorization, and other security checks, ensuring that only legitimate requests are allowed to proceed to the application's business logic.
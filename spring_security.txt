**Cross-Site Request Forgery (CSRF)** is an attack that forces an authenticated user to submit a malicious request. In a CSRF attack, the attacker tricks the victim into performing actions on a web application where they are authenticated, potentially leading to unauthorized actions.

In **Spring Security**, CSRF protection is enabled by default to prevent these types of attacks. It ensures that every HTTP request that modifies the server's state (e.g., POST, PUT, DELETE) contains a valid CSRF token.

### How CSRF Protection Works in Spring Security:
1. **Token Generation**:
   When CSRF protection is enabled, Spring Security generates a **CSRF token** for each session and includes it in the server response (e.g., as a hidden input field in forms).
   
2. **Token Validation**:
   For each subsequent request that modifies server state, the CSRF token must be sent along with the request (e.g., in the request body or header). Spring Security checks the token to verify that the request is legitimate and made by the authenticated user.

### Key Components of CSRF in Spring Security:
- **CSRF Token**: A unique token generated by the server for each session.
- **Token Storage**: The CSRF token is stored in the session or HttpServletRequest.
- **Token Submission**: The token must be included in state-changing HTTP requests (POST, PUT, DELETE).

### Default Behavior:
By default, Spring Security:
- Generates a CSRF token for each session.
- Adds the CSRF token to every form in the application (via the `th:action` attribute in Thymeleaf, for example).
- Rejects any HTTP request that doesn’t include a valid CSRF token.

### Enabling/Disabling CSRF Protection:
CSRF protection is enabled by default in Spring Security, but it can be disabled if your application doesn’t need it (for example, if your application only serves APIs). To disable CSRF protection:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf().disable() // Disables CSRF protection
            .authorizeRequests()
            .anyRequest().authenticated();
    }
}
```

### Customizing CSRF Protection:
You can customize the CSRF token configuration in Spring Security, such as how the token is generated or how it is validated.

1. **Custom CSRF Token Repository**:
   Spring Security uses the `HttpSessionCsrfTokenRepository` by default to store the CSRF token in the user’s session. You can provide a custom CSRF token repository:
   
   ```java
   @Override
   protected void configure(HttpSecurity http) throws Exception {
       http
           .csrf()
           .csrfTokenRepository(new CookieCsrfTokenRepository()) // Store CSRF token in cookies
           .and()
           .authorizeRequests()
           .anyRequest().authenticated();
   }
   ```

2. **Including CSRF Tokens in Requests**:
   When CSRF protection is enabled, the CSRF token must be included in state-modifying requests (like POST or DELETE). If you’re building an HTML form, you can use Thymeleaf to automatically include the token:
   
   ```html
   <form th:action="@{/submit}" method="post">
       <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}" />
       <button type="submit">Submit</button>
   </form>
   ```

3. **Sending CSRF Token via AJAX**:
   If you’re using AJAX (e.g., with JavaScript frameworks like React or Angular), you need to send the CSRF token in the header. Spring Security provides a `meta` tag with the token value:
   
   ```html
   <meta name="_csrf" content="${_csrf.token}"/>
   <meta name="_csrf_header" content="${_csrf.headerName}"/>
   ```
   
   You can use JavaScript to add the token to your AJAX request headers:
   ```javascript
   var token = document.querySelector('meta[name="_csrf"]').getAttribute('content');
   var header = document.querySelector('meta[name="_csrf_header"]').getAttribute('content');

   fetch('/submit', {
       method: 'POST',
       headers: {
           [header]: token
       },
       body: JSON.stringify(data)
   });
   ```

### When to Disable CSRF Protection:
CSRF protection is not necessary for stateless applications or APIs that rely on **token-based authentication** (like JWT), where sessions aren’t used. For REST APIs, it’s common to disable CSRF protection since API clients typically don’t use CSRF tokens.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable() // Disable CSRF for REST APIs
        .authorizeRequests()
        .anyRequest().authenticated();
}
```

### Summary:
- **CSRF** protection is crucial for web applications that use session-based authentication.
- Spring Security provides **automatic CSRF protection** by generating and validating CSRF tokens for each request that modifies server state.
- Tokens must be sent with all modifying requests (e.g., POST, PUT, DELETE).
- It can be customized or disabled for REST APIs or stateless applications.



============================================================================================================================
@Bean
UserDetailsService userDetailsService() {

    UserDetails user1 = User.withDefaultPasswordEncoder().username("Faraz").password("f@123").roles("USER").build();
    UserDetails user2 = User.withDefaultPasswordEncoder().username("Ayush").password("a@123").roles("ADMIN").build();

    return new InMemoryUserDetailsManager(user1, user2);
}

============================================================================================================================
This Spring Security code snippet defines a `UserDetailsService` bean, which is responsible for loading user-specific data during authentication. Let’s break down the key concepts involved:

### 1. **`@Bean` Annotation**:
   The `@Bean` annotation tells Spring that this method produces a bean that will be managed by the Spring container. In this case, the method `userDetailsService()` returns an instance of `UserDetailsService`, which Spring uses for user authentication.

### 2. **`UserDetailsService` Interface**:
   - **Purpose**: The `UserDetailsService` interface is a core component in Spring Security. It is used to retrieve user-related data, and it's called by Spring Security during the authentication process to load user details (like username, password, roles, etc.).
   - **Implementation**: Here, we are returning an instance of `InMemoryUserDetailsManager`, which is a simple implementation of `UserDetailsService` that stores user details in memory (not in a database).

### 3. **UserDetails Interface**:
   - **Purpose**: `UserDetails` is a Spring Security interface that provides the necessary information to build an Authentication object. It represents a user’s authentication information.
   - **User Creation**: Two users (`user1` and `user2`) are being created using the `User.withDefaultPasswordEncoder()` builder method. Each user has a username, password, and roles associated with them:
     - `user1`: Username = "Faraz", Password = "f@123", Role = "USER"
     - `user2`: Username = "Ayush", Password = "a@123", Role = "ADMIN"

### 4. **`User.withDefaultPasswordEncoder()`**:
   - **Purpose**: This is a convenient way to create a user with a default password encoder (which is **not recommended for production use** due to security concerns).
   - **Password Encoding**: Passwords should never be stored or transmitted in plain text. Spring Security requires that passwords be **encoded** before being stored. The `withDefaultPasswordEncoder()` method applies a basic, built-in password encoder that hashes the password using an insecure hashing algorithm (BCrypt is recommended for production).
   - **Why Not for Production**: This default encoder is meant for demonstration purposes only, and it prints a warning that it’s not strong enough for real-world use. In production, you should configure a stronger encoder such as BCrypt:
     ```java
     @Bean
     PasswordEncoder passwordEncoder() {
         return new BCryptPasswordEncoder();
     }
     ```

### 5. **User Roles**:
   - Each user has an associated **role** (e.g., `"USER"`, `"ADMIN"`). These roles are typically used for **authorization** (to control access to different parts of the application).
   - In Spring Security, roles determine what a user is allowed to do in the application. For example, users with the role `"ADMIN"` might have access to administrative features, while users with the role `"USER"` might have limited access.

### 6. **`InMemoryUserDetailsManager`**:
   - This is an implementation of the `UserDetailsService` interface that stores user information **in memory**, which means the user details are not persisted between application restarts. This is mainly used for testing, development, or small applications.
   - Here, it takes the two `UserDetails` objects (`user1` and `user2`) and manages them for authentication.

### Full Code Breakdown:
```java
@Bean
UserDetailsService userDetailsService() {

    // Creating an in-memory user with username "Faraz", password "f@123", and the role "USER"
    UserDetails user1 = User.withDefaultPasswordEncoder()
                            .username("Faraz")
                            .password("f@123")
                            .roles("USER")
                            .build();

    // Creating another in-memory user with username "Ayush", password "a@123", and the role "ADMIN"
    UserDetails user2 = User.withDefaultPasswordEncoder()
                            .username("Ayush")
                            .password("a@123")
                            .roles("ADMIN")
                            .build();

    // Returning an InMemoryUserDetailsManager that stores the users in memory
    return new InMemoryUserDetailsManager(user1, user2);
}
```

### How It Works:
1. **User Creation**: Two users (`Faraz` and `Ayush`) are created with their corresponding usernames, passwords, and roles.
2. **Password Encoding**: The passwords are encoded using the default encoder (for development/testing).
3. **In-Memory User Storage**: The `InMemoryUserDetailsManager` stores these users in memory, allowing Spring Security to authenticate them during login.
4. **Authentication**: When a user tries to log in, Spring Security checks the provided username and password against the users stored in the `InMemoryUserDetailsManager`. If the credentials match, the user is authenticated.

### Summary:
- **InMemoryUserDetailsManager**: A simple user store for testing, storing users in memory.
- **UserDetails**: Represents a user with credentials (username, password, roles).
- **User.withDefaultPasswordEncoder()**: Creates users with a basic password encoder (not suitable for production).
- **Roles**: Define authorization levels, controlling access to parts of the application.

In a real-world application, you would typically fetch users from a database, use a more secure password encoder, and store user credentials securely.

